// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const acceptFollowRequest = `-- name: AcceptFollowRequest :exec
INSERT INTO follows (follower_account_id, following_account_id)
SELECT requester_account_id, requestee_account_id
FROM follow_requests
WHERE requester_account_id = ? AND requestee_account_id = ?
`

type AcceptFollowRequestParams struct {
	RequesterAccountID string
	RequesteeAccountID string
}

func (q *Queries) AcceptFollowRequest(ctx context.Context, arg AcceptFollowRequestParams) error {
	_, err := q.db.ExecContext(ctx, acceptFollowRequest, arg.RequesterAccountID, arg.RequesteeAccountID)
	return err
}

const checkBlockExists = `-- name: CheckBlockExists :one
SELECT EXISTS(
    SELECT 1 FROM blocks
    WHERE blocker_account_id = ? AND blocked_account_id = ?
) AS is_blocked
`

type CheckBlockExistsParams struct {
	BlockerAccountID string
	BlockedAccountID string
}

func (q *Queries) CheckBlockExists(ctx context.Context, arg CheckBlockExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkBlockExists, arg.BlockerAccountID, arg.BlockedAccountID)
	var is_blocked bool
	err := row.Scan(&is_blocked)
	return is_blocked, err
}

const checkFollowExists = `-- name: CheckFollowExists :one
SELECT EXISTS(
    SELECT 1 FROM follows
    WHERE follower_account_id = ? AND following_account_id = ?
) AS is_following
`

type CheckFollowExistsParams struct {
	FollowerAccountID  string
	FollowingAccountID string
}

func (q *Queries) CheckFollowExists(ctx context.Context, arg CheckFollowExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkFollowExists, arg.FollowerAccountID, arg.FollowingAccountID)
	var is_following bool
	err := row.Scan(&is_following)
	return is_following, err
}

const checkProfileExists = `-- name: CheckProfileExists :one
SELECT EXISTS(SELECT 1 FROM profiles WHERE account_id = ?)
`

func (q *Queries) CheckProfileExists(ctx context.Context, accountID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProfileExists, accountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkSettingsExist = `-- name: CheckSettingsExist :one
SELECT EXISTS(SELECT 1 FROM settings WHERE account_id = ?)
`

func (q *Queries) CheckSettingsExist(ctx context.Context, accountID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSettingsExist, accountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkTweetHashtagExists = `-- name: CheckTweetHashtagExists :one
SELECT EXISTS(
    SELECT 1 FROM tweet_hashtags
    WHERE tweet_id = ? AND hashtag_id = ?
) AS hashtag_exists
`

type CheckTweetHashtagExistsParams struct {
	TweetID   uint64
	HashtagID uint64
}

func (q *Queries) CheckTweetHashtagExists(ctx context.Context, arg CheckTweetHashtagExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkTweetHashtagExists, arg.TweetID, arg.HashtagID)
	var hashtag_exists bool
	err := row.Scan(&hashtag_exists)
	return hashtag_exists, err
}

const checkUserIdExists = `-- name: CheckUserIdExists :one
SELECT EXISTS(SELECT 1 FROM accounts WHERE user_id = ?)
`

func (q *Queries) CheckUserIdExists(ctx context.Context, userID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserIdExists, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserNameExists = `-- name: CheckUserNameExists :one
SELECT EXISTS(SELECT 1 FROM accounts WHERE user_name = ?)
`

func (q *Queries) CheckUserNameExists(ctx context.Context, userName string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserNameExists, userName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAccounts = `-- name: CountAccounts :one
SELECT COUNT(*) FROM accounts
`

func (q *Queries) CountAccounts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAccounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO accounts (id, user_id, user_name)
VALUES (?, ?, ?)
`

type CreateAccountParams struct {
	ID       string
	UserID   string
	UserName string
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount, arg.ID, arg.UserID, arg.UserName)
	return err
}

const createBlock = `-- name: CreateBlock :exec
INSERT INTO blocks (blocker_account_id, blocked_account_id)
VALUES (?, ?)
`

type CreateBlockParams struct {
	BlockerAccountID string
	BlockedAccountID string
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) error {
	_, err := q.db.ExecContext(ctx, createBlock, arg.BlockerAccountID, arg.BlockedAccountID)
	return err
}

const createFollow = `-- name: CreateFollow :exec
INSERT INTO follows (follower_account_id, following_account_id)
VALUES (?, ?)
`

type CreateFollowParams struct {
	FollowerAccountID  string
	FollowingAccountID string
}

func (q *Queries) CreateFollow(ctx context.Context, arg CreateFollowParams) error {
	_, err := q.db.ExecContext(ctx, createFollow, arg.FollowerAccountID, arg.FollowingAccountID)
	return err
}

const createFollowRequest = `-- name: CreateFollowRequest :exec
INSERT INTO follow_requests (requester_account_id, requestee_account_id)
VALUES (?, ?)
`

type CreateFollowRequestParams struct {
	RequesterAccountID string
	RequesteeAccountID string
}

func (q *Queries) CreateFollowRequest(ctx context.Context, arg CreateFollowRequestParams) error {
	_, err := q.db.ExecContext(ctx, createFollowRequest, arg.RequesterAccountID, arg.RequesteeAccountID)
	return err
}

const createHashtag = `-- name: CreateHashtag :exec
INSERT INTO hashtags (tag) VALUES (?)
ON DUPLICATE KEY UPDATE id = LAST_INSERT_ID(id)
`

func (q *Queries) CreateHashtag(ctx context.Context, tag string) error {
	_, err := q.db.ExecContext(ctx, createHashtag, tag)
	return err
}

const createInterestsWithDefaultScores = `-- name: CreateInterestsWithDefaultScores :exec
INSERT INTO interests (account_id)
VALUES (?)
`

func (q *Queries) CreateInterestsWithDefaultScores(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, createInterestsWithDefaultScores, accountID)
	return err
}

const createLabel = `-- name: CreateLabel :exec
INSERT INTO labels (tweet_id, label1, label2, label3)
VALUES (?, ?, ?, ?)
`

type CreateLabelParams struct {
	TweetID uint64
	Label1  string
	Label2  sql.NullString
	Label3  sql.NullString
}

func (q *Queries) CreateLabel(ctx context.Context, arg CreateLabelParams) error {
	_, err := q.db.ExecContext(ctx, createLabel,
		arg.TweetID,
		arg.Label1,
		arg.Label2,
		arg.Label3,
	)
	return err
}

const createLike = `-- name: CreateLike :exec
INSERT INTO likes (liking_account_id, original_tweet_id)
VALUES (?, ?)
`

type CreateLikeParams struct {
	LikingAccountID string
	OriginalTweetID uint64
}

func (q *Queries) CreateLike(ctx context.Context, arg CreateLikeParams) error {
	_, err := q.db.ExecContext(ctx, createLike, arg.LikingAccountID, arg.OriginalTweetID)
	return err
}

const createMessage = `-- name: CreateMessage :exec
INSERT INTO messages (sender_account_id, recipient_account_id, content)
VALUES (?, ?, ?)
`

type CreateMessageParams struct {
	SenderAccountID    string
	RecipientAccountID string
	Content            sql.NullString
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) error {
	_, err := q.db.ExecContext(ctx, createMessage, arg.SenderAccountID, arg.RecipientAccountID, arg.Content)
	return err
}

const createNotification = `-- name: CreateNotification :exec
INSERT INTO notifications (sender_account_id, recipient_account_id, type, content)
VALUES (?, ?, ?, ?)
`

type CreateNotificationParams struct {
	SenderAccountID    sql.NullString
	RecipientAccountID string
	Type               string
	Content            sql.NullString
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) error {
	_, err := q.db.ExecContext(ctx, createNotification,
		arg.SenderAccountID,
		arg.RecipientAccountID,
		arg.Type,
		arg.Content,
	)
	return err
}

const createProfile = `-- name: CreateProfile :exec
INSERT INTO profiles (account_id, bio, profile_image_url, banner_image_url)
VALUES (?, ?, ?, ?)
`

type CreateProfileParams struct {
	AccountID       string
	Bio             sql.NullString
	ProfileImageUrl sql.NullString
	BannerImageUrl  sql.NullString
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) error {
	_, err := q.db.ExecContext(ctx, createProfile,
		arg.AccountID,
		arg.Bio,
		arg.ProfileImageUrl,
		arg.BannerImageUrl,
	)
	return err
}

const createReply = `-- name: CreateReply :exec
INSERT INTO replies (reply_id, original_tweet_id, parent_reply_id, replying_account_id)
VALUES (?, ?, ?, ?)
`

type CreateReplyParams struct {
	ReplyID           uint64
	OriginalTweetID   uint64
	ParentReplyID     sql.NullInt64
	ReplyingAccountID string
}

func (q *Queries) CreateReply(ctx context.Context, arg CreateReplyParams) error {
	_, err := q.db.ExecContext(ctx, createReply,
		arg.ReplyID,
		arg.OriginalTweetID,
		arg.ParentReplyID,
		arg.ReplyingAccountID,
	)
	return err
}

const createRetweetOrQuote = `-- name: CreateRetweetOrQuote :exec
INSERT INTO retweets_and_quotes (retweet_id, retweeting_account_id, original_tweet_id)
VALUES (?, ?, ?)
`

type CreateRetweetOrQuoteParams struct {
	RetweetID           uint64
	RetweetingAccountID string
	OriginalTweetID     uint64
}

func (q *Queries) CreateRetweetOrQuote(ctx context.Context, arg CreateRetweetOrQuoteParams) error {
	_, err := q.db.ExecContext(ctx, createRetweetOrQuote, arg.RetweetID, arg.RetweetingAccountID, arg.OriginalTweetID)
	return err
}

const createSettings = `-- name: CreateSettings :exec
INSERT INTO settings (account_id, is_private)
VALUES (?, ?)
`

type CreateSettingsParams struct {
	AccountID string
	IsPrivate bool
}

func (q *Queries) CreateSettings(ctx context.Context, arg CreateSettingsParams) error {
	_, err := q.db.ExecContext(ctx, createSettings, arg.AccountID, arg.IsPrivate)
	return err
}

const createTweet = `-- name: CreateTweet :exec
INSERT INTO tweets (
    account_id, content, code, media
) VALUES (?, ?, ?, ?)
`

type CreateTweetParams struct {
	AccountID string
	Content   sql.NullString
	Code      sql.NullString
	Media     json.RawMessage
}

func (q *Queries) CreateTweet(ctx context.Context, arg CreateTweetParams) error {
	_, err := q.db.ExecContext(ctx, createTweet,
		arg.AccountID,
		arg.Content,
		arg.Code,
		arg.Media,
	)
	return err
}

const createTweetAsQuote = `-- name: CreateTweetAsQuote :exec
INSERT INTO tweets (
    account_id, is_quote, content, code, media
) VALUES (?, TRUE, ?, ?, ?)
`

type CreateTweetAsQuoteParams struct {
	AccountID string
	Content   sql.NullString
	Code      sql.NullString
	Media     json.RawMessage
}

func (q *Queries) CreateTweetAsQuote(ctx context.Context, arg CreateTweetAsQuoteParams) error {
	_, err := q.db.ExecContext(ctx, createTweetAsQuote,
		arg.AccountID,
		arg.Content,
		arg.Code,
		arg.Media,
	)
	return err
}

const createTweetAsReply = `-- name: CreateTweetAsReply :exec
INSERT INTO tweets (
    account_id, is_reply, content, code, media
) VALUES (?, TRUE, ?, ?, ?)
`

type CreateTweetAsReplyParams struct {
	AccountID string
	Content   sql.NullString
	Code      sql.NullString
	Media     json.RawMessage
}

func (q *Queries) CreateTweetAsReply(ctx context.Context, arg CreateTweetAsReplyParams) error {
	_, err := q.db.ExecContext(ctx, createTweetAsReply,
		arg.AccountID,
		arg.Content,
		arg.Code,
		arg.Media,
	)
	return err
}

const createTweetAsRetweet = `-- name: CreateTweetAsRetweet :exec
INSERT INTO tweets (
    account_id, is_retweet
) VALUES (?, TRUE)
`

func (q *Queries) CreateTweetAsRetweet(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, createTweetAsRetweet, accountID)
	return err
}

const createTweetHashtag = `-- name: CreateTweetHashtag :exec
INSERT INTO tweet_hashtags (tweet_id, hashtag_id)
VALUES (?, ?)
`

type CreateTweetHashtagParams struct {
	TweetID   uint64
	HashtagID uint64
}

func (q *Queries) CreateTweetHashtag(ctx context.Context, arg CreateTweetHashtagParams) error {
	_, err := q.db.ExecContext(ctx, createTweetHashtag, arg.TweetID, arg.HashtagID)
	return err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts
WHERE id = ?
`

func (q *Queries) DeleteAccount(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteAccount, id)
	return err
}

const deleteAllBlocksForUser = `-- name: DeleteAllBlocksForUser :exec
DELETE FROM blocks
WHERE blocker_account_id = ? OR blocked_account_id = ?
`

type DeleteAllBlocksForUserParams struct {
	BlockerAccountID string
	BlockedAccountID string
}

func (q *Queries) DeleteAllBlocksForUser(ctx context.Context, arg DeleteAllBlocksForUserParams) error {
	_, err := q.db.ExecContext(ctx, deleteAllBlocksForUser, arg.BlockerAccountID, arg.BlockedAccountID)
	return err
}

const deleteAllHashtagsForTweet = `-- name: DeleteAllHashtagsForTweet :exec
DELETE FROM tweet_hashtags
WHERE tweet_id = ?
`

func (q *Queries) DeleteAllHashtagsForTweet(ctx context.Context, tweetID uint64) error {
	_, err := q.db.ExecContext(ctx, deleteAllHashtagsForTweet, tweetID)
	return err
}

const deleteAllNotificationsForRecipient = `-- name: DeleteAllNotificationsForRecipient :exec
DELETE FROM notifications
WHERE recipient_account_id = ?
`

func (q *Queries) DeleteAllNotificationsForRecipient(ctx context.Context, recipientAccountID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllNotificationsForRecipient, recipientAccountID)
	return err
}

const deleteBlock = `-- name: DeleteBlock :exec
DELETE FROM blocks
WHERE blocker_account_id = ? AND blocked_account_id = ?
`

type DeleteBlockParams struct {
	BlockerAccountID string
	BlockedAccountID string
}

func (q *Queries) DeleteBlock(ctx context.Context, arg DeleteBlockParams) error {
	_, err := q.db.ExecContext(ctx, deleteBlock, arg.BlockerAccountID, arg.BlockedAccountID)
	return err
}

const deleteFollow = `-- name: DeleteFollow :exec
DELETE FROM follows
WHERE follower_account_id = ? AND following_account_id = ?
`

type DeleteFollowParams struct {
	FollowerAccountID  string
	FollowingAccountID string
}

func (q *Queries) DeleteFollow(ctx context.Context, arg DeleteFollowParams) error {
	_, err := q.db.ExecContext(ctx, deleteFollow, arg.FollowerAccountID, arg.FollowingAccountID)
	return err
}

const deleteFollowRequest = `-- name: DeleteFollowRequest :exec
DELETE FROM follow_requests
WHERE requester_account_id = ? AND requestee_account_id = ?
`

type DeleteFollowRequestParams struct {
	RequesterAccountID string
	RequesteeAccountID string
}

func (q *Queries) DeleteFollowRequest(ctx context.Context, arg DeleteFollowRequestParams) error {
	_, err := q.db.ExecContext(ctx, deleteFollowRequest, arg.RequesterAccountID, arg.RequesteeAccountID)
	return err
}

const deleteHashtag = `-- name: DeleteHashtag :exec
DELETE FROM hashtags WHERE id = ?
`

func (q *Queries) DeleteHashtag(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, deleteHashtag, id)
	return err
}

const deleteInterests = `-- name: DeleteInterests :exec
DELETE FROM interests
WHERE account_id = ?
`

func (q *Queries) DeleteInterests(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteInterests, accountID)
	return err
}

const deleteLabel = `-- name: DeleteLabel :exec
DELETE FROM labels
WHERE tweet_id = ?
`

func (q *Queries) DeleteLabel(ctx context.Context, tweetID uint64) error {
	_, err := q.db.ExecContext(ctx, deleteLabel, tweetID)
	return err
}

const deleteLike = `-- name: DeleteLike :exec
DELETE FROM likes
WHERE liking_account_id = ? AND original_tweet_id = ?
`

type DeleteLikeParams struct {
	LikingAccountID string
	OriginalTweetID uint64
}

func (q *Queries) DeleteLike(ctx context.Context, arg DeleteLikeParams) error {
	_, err := q.db.ExecContext(ctx, deleteLike, arg.LikingAccountID, arg.OriginalTweetID)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages
WHERE id = ? AND (sender_account_id = ? OR recipient_account_id = ?)
`

type DeleteMessageParams struct {
	ID                 uint32
	SenderAccountID    string
	RecipientAccountID string
}

func (q *Queries) DeleteMessage(ctx context.Context, arg DeleteMessageParams) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, arg.ID, arg.SenderAccountID, arg.RecipientAccountID)
	return err
}

const deleteNotification = `-- name: DeleteNotification :exec
DELETE FROM notifications
WHERE id = ? AND recipient_account_id = ?
`

type DeleteNotificationParams struct {
	ID                 uint32
	RecipientAccountID string
}

func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) error {
	_, err := q.db.ExecContext(ctx, deleteNotification, arg.ID, arg.RecipientAccountID)
	return err
}

const deleteOldFollowRequests = `-- name: DeleteOldFollowRequests :exec
DELETE FROM follow_requests
WHERE created_at < ? AND requestee_account_id = ?
`

type DeleteOldFollowRequestsParams struct {
	CreatedAt          time.Time
	RequesteeAccountID string
}

func (q *Queries) DeleteOldFollowRequests(ctx context.Context, arg DeleteOldFollowRequestsParams) error {
	_, err := q.db.ExecContext(ctx, deleteOldFollowRequests, arg.CreatedAt, arg.RequesteeAccountID)
	return err
}

const deleteOldMessages = `-- name: DeleteOldMessages :exec
DELETE FROM messages
WHERE created_at < ? AND is_read = TRUE
`

func (q *Queries) DeleteOldMessages(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldMessages, createdAt)
	return err
}

const deleteOldReadNotifications = `-- name: DeleteOldReadNotifications :exec
DELETE FROM notifications
WHERE recipient_account_id = ? AND is_read = TRUE AND created_at < ?
`

type DeleteOldReadNotificationsParams struct {
	RecipientAccountID string
	CreatedAt          time.Time
}

func (q *Queries) DeleteOldReadNotifications(ctx context.Context, arg DeleteOldReadNotificationsParams) error {
	_, err := q.db.ExecContext(ctx, deleteOldReadNotifications, arg.RecipientAccountID, arg.CreatedAt)
	return err
}

const deleteProfile = `-- name: DeleteProfile :exec
DELETE FROM profiles
WHERE account_id = ?
`

func (q *Queries) DeleteProfile(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteProfile, accountID)
	return err
}

const deleteReply = `-- name: DeleteReply :exec
DELETE FROM replies WHERE reply_id = ?
`

func (q *Queries) DeleteReply(ctx context.Context, replyID uint64) error {
	_, err := q.db.ExecContext(ctx, deleteReply, replyID)
	return err
}

const deleteRetweetOrQuote = `-- name: DeleteRetweetOrQuote :exec
DELETE FROM retweets_and_quotes
WHERE retweet_id = ?
`

func (q *Queries) DeleteRetweetOrQuote(ctx context.Context, retweetID uint64) error {
	_, err := q.db.ExecContext(ctx, deleteRetweetOrQuote, retweetID)
	return err
}

const deleteSettings = `-- name: DeleteSettings :exec
DELETE FROM settings
WHERE account_id = ?
`

func (q *Queries) DeleteSettings(ctx context.Context, accountID string) error {
	_, err := q.db.ExecContext(ctx, deleteSettings, accountID)
	return err
}

const deleteTweet = `-- name: DeleteTweet :exec
DELETE FROM tweets WHERE id = ? AND account_id = ?
`

type DeleteTweetParams struct {
	ID        uint64
	AccountID string
}

func (q *Queries) DeleteTweet(ctx context.Context, arg DeleteTweetParams) error {
	_, err := q.db.ExecContext(ctx, deleteTweet, arg.ID, arg.AccountID)
	return err
}

const deleteTweetHashtag = `-- name: DeleteTweetHashtag :exec
DELETE FROM tweet_hashtags
WHERE tweet_id = ? AND hashtag_id = ?
`

type DeleteTweetHashtagParams struct {
	TweetID   uint64
	HashtagID uint64
}

func (q *Queries) DeleteTweetHashtag(ctx context.Context, arg DeleteTweetHashtagParams) error {
	_, err := q.db.ExecContext(ctx, deleteTweetHashtag, arg.TweetID, arg.HashtagID)
	return err
}

const gerUnreadMessageCountBetweenUsers = `-- name: GerUnreadMessageCountBetweenUsers :one
SELECT COUNT(*) FROM messages
WHERE recipient_account_id = ? AND sender_account_id = ? AND is_read = FALSE
`

type GerUnreadMessageCountBetweenUsersParams struct {
	RecipientAccountID string
	SenderAccountID    string
}

func (q *Queries) GerUnreadMessageCountBetweenUsers(ctx context.Context, arg GerUnreadMessageCountBetweenUsersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, gerUnreadMessageCountBetweenUsers, arg.RecipientAccountID, arg.SenderAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAccountById = `-- name: GetAccountById :one
SELECT id, user_id, user_name, created_at, updated_at FROM accounts
WHERE id = ?
`

func (q *Queries) GetAccountById(ctx context.Context, id string) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByUserId = `-- name: GetAccountByUserId :one
SELECT id, user_id, user_name, created_at, updated_at FROM accounts
WHERE user_id = ?
`

func (q *Queries) GetAccountByUserId(ctx context.Context, userID string) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountByUserId, userID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByUserName = `-- name: GetAccountByUserName :one
SELECT id, user_id, user_name, created_at, updated_at FROM accounts
WHERE user_name = ?
`

func (q *Queries) GetAccountByUserName(ctx context.Context, userName string) (Account, error) {
	row := q.db.QueryRowContext(ctx, getAccountByUserName, userName)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountCreationDate = `-- name: GetAccountCreationDate :one
SELECT created_at FROM accounts
WHERE id = ?
`

func (q *Queries) GetAccountCreationDate(ctx context.Context, id string) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getAccountCreationDate, id)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const getAllHashtags = `-- name: GetAllHashtags :many
SELECT id, tag, created_at FROM hashtags
ORDER BY tag ASC
LIMIT ? OFFSET ?
`

type GetAllHashtagsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAllHashtags(ctx context.Context, arg GetAllHashtagsParams) ([]Hashtag, error) {
	rows, err := q.db.QueryContext(ctx, getAllHashtags, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hashtag
	for rows.Next() {
		var i Hashtag
		if err := rows.Scan(&i.ID, &i.Tag, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockCount = `-- name: GetBlockCount :one
SELECT COUNT(*) FROM blocks
WHERE blocker_account_id = ?
`

func (q *Queries) GetBlockCount(ctx context.Context, blockerAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBlockCount, blockerAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBlockedByCount = `-- name: GetBlockedByCount :one
SELECT COUNT(*) FROM blocks
WHERE blocked_account_id = ?
`

func (q *Queries) GetBlockedByCount(ctx context.Context, blockedAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBlockedByCount, blockedAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBlockedUsers = `-- name: GetBlockedUsers :many
SELECT blocked_account_id
FROM blocks
WHERE blocker_account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetBlockedUsersParams struct {
	BlockerAccountID string
	Limit            int32
	Offset           int32
}

func (q *Queries) GetBlockedUsers(ctx context.Context, arg GetBlockedUsersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getBlockedUsers, arg.BlockerAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var blocked_account_id string
		if err := rows.Scan(&blocked_account_id); err != nil {
			return nil, err
		}
		items = append(items, blocked_account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockersOfUser = `-- name: GetBlockersOfUser :many
SELECT blocker_account_id
FROM blocks
WHERE blocked_account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetBlockersOfUserParams struct {
	BlockedAccountID string
	Limit            int32
	Offset           int32
}

func (q *Queries) GetBlockersOfUser(ctx context.Context, arg GetBlockersOfUserParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getBlockersOfUser, arg.BlockedAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var blocker_account_id string
		if err := rows.Scan(&blocker_account_id); err != nil {
			return nil, err
		}
		items = append(items, blocker_account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowSuggestions = `-- name: GetFollowSuggestions :many
SELECT DISTINCT f2.following_account_id
FROM follows f1
JOIN follows f2 ON f1.following_account_id = f2.follower_account_id
WHERE f1.follower_account_id = ?
    AND f2.following_account_id != f1.follower_account_id
    AND NOT EXISTS (
        SELECT 1 FROM follows f3
        WHERE f3.follower_account_id = f1.follower_account_id
            AND f3.following_account_id = f2.following_account_id
    )
LIMIT ?
`

type GetFollowSuggestionsParams struct {
	FollowerAccountID string
	Limit             int32
}

func (q *Queries) GetFollowSuggestions(ctx context.Context, arg GetFollowSuggestionsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFollowSuggestions, arg.FollowerAccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var following_account_id string
		if err := rows.Scan(&following_account_id); err != nil {
			return nil, err
		}
		items = append(items, following_account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowerCount = `-- name: GetFollowerCount :one
SELECT COUNT(*) FROM follows
WHERE following_account_id = ?
`

func (q *Queries) GetFollowerCount(ctx context.Context, followingAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFollowerCount, followingAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFollowers = `-- name: GetFollowers :many
SELECT follower_account_id
FROM follows
WHERE following_account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetFollowersParams struct {
	FollowingAccountID string
	Limit              int32
	Offset             int32
}

func (q *Queries) GetFollowers(ctx context.Context, arg GetFollowersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFollowers, arg.FollowingAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var follower_account_id string
		if err := rows.Scan(&follower_account_id); err != nil {
			return nil, err
		}
		items = append(items, follower_account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowing = `-- name: GetFollowing :many
SELECT following_account_id
FROM follows
WHERE follower_account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetFollowingParams struct {
	FollowerAccountID string
	Limit             int32
	Offset            int32
}

func (q *Queries) GetFollowing(ctx context.Context, arg GetFollowingParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFollowing, arg.FollowerAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var following_account_id string
		if err := rows.Scan(&following_account_id); err != nil {
			return nil, err
		}
		items = append(items, following_account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowingCount = `-- name: GetFollowingCount :one
SELECT COUNT(*) FROM follows
WHERE follower_account_id = ?
`

func (q *Queries) GetFollowingCount(ctx context.Context, followerAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFollowingCount, followerAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getHashtagById = `-- name: GetHashtagById :one
SELECT id, tag, created_at FROM hashtags WHERE id = ?
`

func (q *Queries) GetHashtagById(ctx context.Context, id uint64) (Hashtag, error) {
	row := q.db.QueryRowContext(ctx, getHashtagById, id)
	var i Hashtag
	err := row.Scan(&i.ID, &i.Tag, &i.CreatedAt)
	return i, err
}

const getHashtagByTag = `-- name: GetHashtagByTag :one
SELECT id, tag, created_at FROM hashtags WHERE tag = ?
`

func (q *Queries) GetHashtagByTag(ctx context.Context, tag string) (Hashtag, error) {
	row := q.db.QueryRowContext(ctx, getHashtagByTag, tag)
	var i Hashtag
	err := row.Scan(&i.ID, &i.Tag, &i.CreatedAt)
	return i, err
}

const getHashtagCount = `-- name: GetHashtagCount :one
SELECT COUNT(*) FROM hashtags
`

func (q *Queries) GetHashtagCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getHashtagCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getHashtagsByTweetId = `-- name: GetHashtagsByTweetId :many
SELECT h.id, h.tag, h.created_at
FROM hashtags h
JOIN tweet_hashtags th ON h.id = th.hashtag_id
WHERE th.tweet_id = ?
`

func (q *Queries) GetHashtagsByTweetId(ctx context.Context, tweetID uint64) ([]Hashtag, error) {
	rows, err := q.db.QueryContext(ctx, getHashtagsByTweetId, tweetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hashtag
	for rows.Next() {
		var i Hashtag
		if err := rows.Scan(&i.ID, &i.Tag, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInterestByAccountId = `-- name: GetInterestByAccountId :one
SELECT account_id, news_score, politics_score, economics_score, health_score, sports_score, entertainment_score, art_score, cooking_score, travel_score, fashion_score, beauty_score, pets_score, parenting_score, education_score, environment_score, climate_score, space_score, mental_health_score, fitness_score, reading_score, history_score, philosophy_score, religion_score, culture_score, volunteering_score, social_issues_score, law_score, taxes_score, investment_score, real_estate_score, diy_score, gardening_score, interior_design_score, automotive_score, gaming_score, anime_manga_score, creative_works_score, photography_video_score, media_score, marketing_score, branding_score, entrepreneurship_score, remote_work_score, data_science_score, iot_score, robotics_engineering_score, biotechnology_score, nanotechnology_score, energy_technology_score, archaeology_score, psychology_score, sociology_score, anthropology_score, geography_score, geology_score, meteorology_score, disaster_emergency_management_score, urban_planning_score, architecture_score, agriculture_score, nutrition_science_score, sleep_science_score, productivity_score, leadership_score, international_relations_score, future_predictions_score, events_score, community_score, trends_score, lifestyle_score, software_development_score, programming_languages_score, web_development_score, mobile_app_development_score, debugging_techniques_score, algorithms_mathematics_score, database_design_score, cloud_computing_score, server_management_score, network_security_score, cryptography_score, artificial_intelligence_score, machine_learning_score, deep_learning_score, computer_vision_score, natural_language_processing_score, blockchain_technology_score, quantum_computing_score, edge_computing_score, microservices_architecture_score, devops_score, container_technology_score, ci_cd_score, test_automation_score, ux_ui_design_score, agile_development_methodologies_score, open_source_score, version_control_score, api_design_score, performance_optimization_score FROM interests
WHERE account_id = ?
`

func (q *Queries) GetInterestByAccountId(ctx context.Context, accountID string) (Interest, error) {
	row := q.db.QueryRowContext(ctx, getInterestByAccountId, accountID)
	var i Interest
	err := row.Scan(
		&i.AccountID,
		&i.NewsScore,
		&i.PoliticsScore,
		&i.EconomicsScore,
		&i.HealthScore,
		&i.SportsScore,
		&i.EntertainmentScore,
		&i.ArtScore,
		&i.CookingScore,
		&i.TravelScore,
		&i.FashionScore,
		&i.BeautyScore,
		&i.PetsScore,
		&i.ParentingScore,
		&i.EducationScore,
		&i.EnvironmentScore,
		&i.ClimateScore,
		&i.SpaceScore,
		&i.MentalHealthScore,
		&i.FitnessScore,
		&i.ReadingScore,
		&i.HistoryScore,
		&i.PhilosophyScore,
		&i.ReligionScore,
		&i.CultureScore,
		&i.VolunteeringScore,
		&i.SocialIssuesScore,
		&i.LawScore,
		&i.TaxesScore,
		&i.InvestmentScore,
		&i.RealEstateScore,
		&i.DiyScore,
		&i.GardeningScore,
		&i.InteriorDesignScore,
		&i.AutomotiveScore,
		&i.GamingScore,
		&i.AnimeMangaScore,
		&i.CreativeWorksScore,
		&i.PhotographyVideoScore,
		&i.MediaScore,
		&i.MarketingScore,
		&i.BrandingScore,
		&i.EntrepreneurshipScore,
		&i.RemoteWorkScore,
		&i.DataScienceScore,
		&i.IotScore,
		&i.RoboticsEngineeringScore,
		&i.BiotechnologyScore,
		&i.NanotechnologyScore,
		&i.EnergyTechnologyScore,
		&i.ArchaeologyScore,
		&i.PsychologyScore,
		&i.SociologyScore,
		&i.AnthropologyScore,
		&i.GeographyScore,
		&i.GeologyScore,
		&i.MeteorologyScore,
		&i.DisasterEmergencyManagementScore,
		&i.UrbanPlanningScore,
		&i.ArchitectureScore,
		&i.AgricultureScore,
		&i.NutritionScienceScore,
		&i.SleepScienceScore,
		&i.ProductivityScore,
		&i.LeadershipScore,
		&i.InternationalRelationsScore,
		&i.FuturePredictionsScore,
		&i.EventsScore,
		&i.CommunityScore,
		&i.TrendsScore,
		&i.LifestyleScore,
		&i.SoftwareDevelopmentScore,
		&i.ProgrammingLanguagesScore,
		&i.WebDevelopmentScore,
		&i.MobileAppDevelopmentScore,
		&i.DebuggingTechniquesScore,
		&i.AlgorithmsMathematicsScore,
		&i.DatabaseDesignScore,
		&i.CloudComputingScore,
		&i.ServerManagementScore,
		&i.NetworkSecurityScore,
		&i.CryptographyScore,
		&i.ArtificialIntelligenceScore,
		&i.MachineLearningScore,
		&i.DeepLearningScore,
		&i.ComputerVisionScore,
		&i.NaturalLanguageProcessingScore,
		&i.BlockchainTechnologyScore,
		&i.QuantumComputingScore,
		&i.EdgeComputingScore,
		&i.MicroservicesArchitectureScore,
		&i.DevopsScore,
		&i.ContainerTechnologyScore,
		&i.CiCdScore,
		&i.TestAutomationScore,
		&i.UxUiDesignScore,
		&i.AgileDevelopmentMethodologiesScore,
		&i.OpenSourceScore,
		&i.VersionControlScore,
		&i.ApiDesignScore,
		&i.PerformanceOptimizationScore,
	)
	return i, err
}

const getLabelsByTweetId = `-- name: GetLabelsByTweetId :one
SELECT tweet_id, label1, label2, label3, created_at FROM labels
WHERE tweet_id = ?
`

func (q *Queries) GetLabelsByTweetId(ctx context.Context, tweetID uint64) (Label, error) {
	row := q.db.QueryRowContext(ctx, getLabelsByTweetId, tweetID)
	var i Label
	err := row.Scan(
		&i.TweetID,
		&i.Label1,
		&i.Label2,
		&i.Label3,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestMessageForEachConversation = `-- name: GetLatestMessageForEachConversation :many
SELECT m.id, m.sender_account_id, m.recipient_account_id, m.content, m.is_read, m.created_at, m.updated_at
FROM messages m
INNER JOIN (
    SELECT
        CASE
            WHEN sender_account_id < recipient_account_id
            THEN sender_account_id
            ELSE recipient_account_id
        END AS user1,
        CASE
            WHEN sender_account_id < recipient_account_id
            THEN recipient_account_id
            ELSE sender_account_id
        END AS user2,
        MAX(created_at) AS max_created_at
    FROM messages m2
    WHERE m2.sender_account_id = ? OR m2.recipient_account_id = ?
    GROUP BY user1, user2
) latest ON (
    (m.sender_account_id = latest.user1 AND m.recipient_account_id = latest.user2) OR
    (m.sender_account_id = latest.user2 AND m.recipient_account_id = latest.user1)
) AND m.created_at = latest.max_created_at
ORDER BY m.created_at DESC
`

type GetLatestMessageForEachConversationParams struct {
	SenderAccountID    string
	RecipientAccountID string
}

func (q *Queries) GetLatestMessageForEachConversation(ctx context.Context, arg GetLatestMessageForEachConversationParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getLatestMessageForEachConversation, arg.SenderAccountID, arg.RecipientAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderAccountID,
			&i.RecipientAccountID,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikeCount = `-- name: GetLikeCount :one
SELECT COUNT(*) FROM likes
WHERE original_tweet_id = ?
`

func (q *Queries) GetLikeCount(ctx context.Context, originalTweetID uint64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLikeCount, originalTweetID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLikesByAccountId = `-- name: GetLikesByAccountId :many
SELECT liking_account_id, original_tweet_id, created_at FROM likes
WHERE liking_account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetLikesByAccountIdParams struct {
	LikingAccountID string
	Limit           int32
	Offset          int32
}

func (q *Queries) GetLikesByAccountId(ctx context.Context, arg GetLikesByAccountIdParams) ([]Like, error) {
	rows, err := q.db.QueryContext(ctx, getLikesByAccountId, arg.LikingAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Like
	for rows.Next() {
		var i Like
		if err := rows.Scan(&i.LikingAccountID, &i.OriginalTweetID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikesByTweetId = `-- name: GetLikesByTweetId :many
SELECT liking_account_id, original_tweet_id, created_at FROM likes
WHERE original_tweet_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetLikesByTweetIdParams struct {
	OriginalTweetID uint64
	Limit           int32
	Offset          int32
}

func (q *Queries) GetLikesByTweetId(ctx context.Context, arg GetLikesByTweetIdParams) ([]Like, error) {
	rows, err := q.db.QueryContext(ctx, getLikesByTweetId, arg.OriginalTweetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Like
	for rows.Next() {
		var i Like
		if err := rows.Scan(&i.LikingAccountID, &i.OriginalTweetID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageById = `-- name: GetMessageById :one
SELECT id, sender_account_id, recipient_account_id, content, is_read, created_at, updated_at FROM messages
WHERE id = ?
`

func (q *Queries) GetMessageById(ctx context.Context, id uint32) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessageById, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SenderAccountID,
		&i.RecipientAccountID,
		&i.Content,
		&i.IsRead,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageCountForUser = `-- name: GetMessageCountForUser :one
SELECT COUNT(*) FROM messages
WHERE sender_account_id = ? OR recipient_account_id = ?
`

type GetMessageCountForUserParams struct {
	SenderAccountID    string
	RecipientAccountID string
}

func (q *Queries) GetMessageCountForUser(ctx context.Context, arg GetMessageCountForUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMessageCountForUser, arg.SenderAccountID, arg.RecipientAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMessagesBetweenUsers = `-- name: GetMessagesBetweenUsers :many
SELECT id, sender_account_id, recipient_account_id, content, is_read, created_at, updated_at FROM messages
WHERE (sender_account_id = ? AND recipient_account_id = ?)
    OR (sender_account_id = ? AND recipient_account_id = ?)
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetMessagesBetweenUsersParams struct {
	SenderAccountID      string
	RecipientAccountID   string
	SenderAccountID_2    string
	RecipientAccountID_2 string
	Limit                int32
	Offset               int32
}

func (q *Queries) GetMessagesBetweenUsers(ctx context.Context, arg GetMessagesBetweenUsersParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesBetweenUsers,
		arg.SenderAccountID,
		arg.RecipientAccountID,
		arg.SenderAccountID_2,
		arg.RecipientAccountID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderAccountID,
			&i.RecipientAccountID,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostUsedHashtags = `-- name: GetMostUsedHashtags :many
SELECT h.id, h.tag, h.created_at, COUNT(th.tweet_id) as usage_count
FROM hashtags h
JOIN tweet_hashtags th ON h.id = th.hashtag_id
GROUP BY h.id
ORDER BY usage_count DESC
LIMIT ?
`

type GetMostUsedHashtagsRow struct {
	ID         uint64
	Tag        string
	CreatedAt  time.Time
	UsageCount int64
}

func (q *Queries) GetMostUsedHashtags(ctx context.Context, limit int32) ([]GetMostUsedHashtagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostUsedHashtags, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostUsedHashtagsRow
	for rows.Next() {
		var i GetMostUsedHashtagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.CreatedAt,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMutualFollows = `-- name: GetMutualFollows :many
SELECT f1.following_account_id
FROM follows f1
JOIN follows f2 ON f1.following_account_id = f2.follower_account_id
WHERE f1.follower_account_id = ? AND f2.following_account_id = ?
LIMIT ? OFFSET ?
`

type GetMutualFollowsParams struct {
	FollowerAccountID  string
	FollowingAccountID string
	Limit              int32
	Offset             int32
}

func (q *Queries) GetMutualFollows(ctx context.Context, arg GetMutualFollowsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getMutualFollows,
		arg.FollowerAccountID,
		arg.FollowingAccountID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var following_account_id string
		if err := rows.Scan(&following_account_id); err != nil {
			return nil, err
		}
		items = append(items, following_account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationById = `-- name: GetNotificationById :one
SELECT id, sender_account_id, recipient_account_id, type, content, is_read, created_at, updated_at FROM notifications
WHERE id = ?
`

func (q *Queries) GetNotificationById(ctx context.Context, id uint32) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationById, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.SenderAccountID,
		&i.RecipientAccountID,
		&i.Type,
		&i.Content,
		&i.IsRead,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNotificationCountByRecipientId = `-- name: GetNotificationCountByRecipientId :one
SELECT COUNT(*) FROM notifications
WHERE recipient_account_id = ?
`

func (q *Queries) GetNotificationCountByRecipientId(ctx context.Context, recipientAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNotificationCountByRecipientId, recipientAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNotificationsByRecipientId = `-- name: GetNotificationsByRecipientId :many
SELECT id, sender_account_id, recipient_account_id, type, content, is_read, created_at, updated_at FROM notifications
WHERE recipient_account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetNotificationsByRecipientIdParams struct {
	RecipientAccountID string
	Limit              int32
	Offset             int32
}

func (q *Queries) GetNotificationsByRecipientId(ctx context.Context, arg GetNotificationsByRecipientIdParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getNotificationsByRecipientId, arg.RecipientAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.SenderAccountID,
			&i.RecipientAccountID,
			&i.Type,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsByType = `-- name: GetNotificationsByType :many
SELECT id, sender_account_id, recipient_account_id, type, content, is_read, created_at, updated_at FROM notifications
WHERE recipient_account_id = ? AND type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetNotificationsByTypeParams struct {
	RecipientAccountID string
	Type               string
	Limit              int32
	Offset             int32
}

func (q *Queries) GetNotificationsByType(ctx context.Context, arg GetNotificationsByTypeParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getNotificationsByType,
		arg.RecipientAccountID,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.SenderAccountID,
			&i.RecipientAccountID,
			&i.Type,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingFollowRequestCount = `-- name: GetPendingFollowRequestCount :one
SELECT COUNT(*) FROM follow_requests
WHERE requestee_account_id = ?
`

func (q *Queries) GetPendingFollowRequestCount(ctx context.Context, requesteeAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingFollowRequestCount, requesteeAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPendingFollowRequests = `-- name: GetPendingFollowRequests :many
SELECT requester_account_id
FROM follow_requests
WHERE requestee_account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetPendingFollowRequestsParams struct {
	RequesteeAccountID string
	Limit              int32
	Offset             int32
}

func (q *Queries) GetPendingFollowRequests(ctx context.Context, arg GetPendingFollowRequestsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getPendingFollowRequests, arg.RequesteeAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var requester_account_id string
		if err := rows.Scan(&requester_account_id); err != nil {
			return nil, err
		}
		items = append(items, requester_account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPinnedTweetForAccount = `-- name: GetPinnedTweetForAccount :one
SELECT id, account_id, is_pinned, content, code, likes_count, replies_count, retweets_count, is_retweet, is_reply, is_quote, engagement_score, media, created_at, updated_at FROM tweets
WHERE account_id = ? AND is_pinned = TRUE
LIMIT 1
`

func (q *Queries) GetPinnedTweetForAccount(ctx context.Context, accountID string) (Tweet, error) {
	row := q.db.QueryRowContext(ctx, getPinnedTweetForAccount, accountID)
	var i Tweet
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.IsPinned,
		&i.Content,
		&i.Code,
		&i.LikesCount,
		&i.RepliesCount,
		&i.RetweetsCount,
		&i.IsRetweet,
		&i.IsReply,
		&i.IsQuote,
		&i.EngagementScore,
		&i.Media,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProfileByAccountId = `-- name: GetProfileByAccountId :one
SELECT account_id, bio, profile_image_url, banner_image_url, created_at, updated_at FROM profiles
WHERE account_id = ?
`

func (q *Queries) GetProfileByAccountId(ctx context.Context, accountID string) (Profile, error) {
	row := q.db.QueryRowContext(ctx, getProfileByAccountId, accountID)
	var i Profile
	err := row.Scan(
		&i.AccountID,
		&i.Bio,
		&i.ProfileImageUrl,
		&i.BannerImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecentTweetsWithHashtag = `-- name: GetRecentTweetsWithHashtag :many
SELECT t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_retweet, t.is_reply, t.is_quote, t.engagement_score, t.media, t.created_at, t.updated_at, h.tag
FROM tweets t
JOIN tweet_hashtags th ON t.id = th.tweet_id
JOIN hashtags h ON th.hashtag_id = h.id
WHERE h.tag = ?
ORDER BY t.created_at DESC
LIMIT ?
`

type GetRecentTweetsWithHashtagParams struct {
	Tag   string
	Limit int32
}

type GetRecentTweetsWithHashtagRow struct {
	ID              uint64
	AccountID       string
	IsPinned        bool
	Content         sql.NullString
	Code            sql.NullString
	LikesCount      uint32
	RepliesCount    uint32
	RetweetsCount   uint32
	IsRetweet       bool
	IsReply         bool
	IsQuote         bool
	EngagementScore uint32
	Media           json.RawMessage
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Tag             string
}

func (q *Queries) GetRecentTweetsWithHashtag(ctx context.Context, arg GetRecentTweetsWithHashtagParams) ([]GetRecentTweetsWithHashtagRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentTweetsWithHashtag, arg.Tag, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentTweetsWithHashtagRow
	for rows.Next() {
		var i GetRecentTweetsWithHashtagRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReplyById = `-- name: GetReplyById :one
SELECT reply_id, original_tweet_id, parent_reply_id, replying_account_id, created_at FROM replies WHERE reply_id = ?
`

func (q *Queries) GetReplyById(ctx context.Context, replyID uint64) (Reply, error) {
	row := q.db.QueryRowContext(ctx, getReplyById, replyID)
	var i Reply
	err := row.Scan(
		&i.ReplyID,
		&i.OriginalTweetID,
		&i.ParentReplyID,
		&i.ReplyingAccountID,
		&i.CreatedAt,
	)
	return i, err
}

const getReplyCount = `-- name: GetReplyCount :one



SELECT COUNT(*) FROM replies WHERE original_tweet_id = ?
`

// -- name: GetRepliesByOriginalTweetId :many
// SELECT r.*, t.content AS reply_content, a.user_name AS replier_name
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN accounts a ON r.replying_account_id = a.id
// WHERE r.original_tweet_id = ?
// ORDER BY r.created_at ASC
// LIMIT ? OFFSET ?;
// -- name: GetRepliesByParentReplyId :many
// SELECT r.*, t.content AS reply_content, a.user_name AS replier_name
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN accounts a ON r.replying_account_id = a.id
// WHERE r.parent_reply_id = ?
// ORDER BY r.created_at ASC
// LIMIT ? OFFSET ?;
// -- name: GetRepliesByAccountId :many
// SELECT r.*, t.content AS reply_content, ot.content AS original_tweet_content
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN tweets ot ON r.original_tweet_id = ot.id
// WHERE r.replying_account_id = ?
// ORDER BY r.created_at DESC
// LIMIT ? OFFSET ?;
func (q *Queries) GetReplyCount(ctx context.Context, originalTweetID uint64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReplyCount, originalTweetID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getReplyThread = `-- name: GetReplyThread :many
WITH RECURSIVE reply_thread AS (
    SELECT reply_id, original_tweet_id, parent_reply_id, replying_account_id, created_at FROM replies r0 WHERE r0.reply_id = ?
    UNION ALL
    SELECT r.reply_id, r.original_tweet_id, r.parent_reply_id, r.replying_account_id, r.created_at FROM replies r
    JOIN reply_thread rt ON r.parent_reply_id = rt.reply_id
)
SELECT rt.reply_id, rt.original_tweet_id, rt.parent_reply_id, rt.replying_account_id, rt.created_at, t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_retweet, t.is_reply, t.is_quote, t.engagement_score, t.media, t.created_at, t.updated_at
FROM reply_thread rt
JOIN tweets t ON rt.reply_id = t.id
ORDER BY rt.created_at ASC
`

type GetReplyThreadRow struct {
	ReplyID           uint64
	OriginalTweetID   uint64
	ParentReplyID     sql.NullInt64
	ReplyingAccountID string
	CreatedAt         time.Time
	ID                uint64
	AccountID         string
	IsPinned          bool
	Content           sql.NullString
	Code              sql.NullString
	LikesCount        uint32
	RepliesCount      uint32
	RetweetsCount     uint32
	IsRetweet         bool
	IsReply           bool
	IsQuote           bool
	EngagementScore   uint32
	Media             json.RawMessage
	CreatedAt_2       time.Time
	UpdatedAt         time.Time
}

func (q *Queries) GetReplyThread(ctx context.Context, replyID uint64) ([]GetReplyThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, getReplyThread, replyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReplyThreadRow
	for rows.Next() {
		var i GetReplyThreadRow
		if err := rows.Scan(
			&i.ReplyID,
			&i.OriginalTweetID,
			&i.ParentReplyID,
			&i.ReplyingAccountID,
			&i.CreatedAt,
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt_2,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRetweetAndQuoteCount = `-- name: GetRetweetAndQuoteCount :one
SELECT COUNT(*) FROM retweets_and_quotes
WHERE original_tweet_id = ?
`

func (q *Queries) GetRetweetAndQuoteCount(ctx context.Context, originalTweetID uint64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getRetweetAndQuoteCount, originalTweetID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRetweetOrQuoteById = `-- name: GetRetweetOrQuoteById :one
SELECT retweet_id, retweeting_account_id, original_tweet_id, created_at FROM retweets_and_quotes
WHERE retweet_id = ?
`

func (q *Queries) GetRetweetOrQuoteById(ctx context.Context, retweetID uint64) (RetweetsAndQuote, error) {
	row := q.db.QueryRowContext(ctx, getRetweetOrQuoteById, retweetID)
	var i RetweetsAndQuote
	err := row.Scan(
		&i.RetweetID,
		&i.RetweetingAccountID,
		&i.OriginalTweetID,
		&i.CreatedAt,
	)
	return i, err
}

const getRetweetsAndQuotesByAccountId = `-- name: GetRetweetsAndQuotesByAccountId :many
SELECT r.retweet_id, r.retweeting_account_id, r.original_tweet_id, r.created_at, t.content AS original_tweet_content
FROM retweets_and_quotes r
JOIN tweets t ON r.original_tweet_id = t.id
WHERE r.retweeting_account_id = ?
ORDER BY r.created_at DESC
LIMIT ? OFFSET ?
`

type GetRetweetsAndQuotesByAccountIdParams struct {
	RetweetingAccountID string
	Limit               int32
	Offset              int32
}

type GetRetweetsAndQuotesByAccountIdRow struct {
	RetweetID            uint64
	RetweetingAccountID  string
	OriginalTweetID      uint64
	CreatedAt            time.Time
	OriginalTweetContent sql.NullString
}

func (q *Queries) GetRetweetsAndQuotesByAccountId(ctx context.Context, arg GetRetweetsAndQuotesByAccountIdParams) ([]GetRetweetsAndQuotesByAccountIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRetweetsAndQuotesByAccountId, arg.RetweetingAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRetweetsAndQuotesByAccountIdRow
	for rows.Next() {
		var i GetRetweetsAndQuotesByAccountIdRow
		if err := rows.Scan(
			&i.RetweetID,
			&i.RetweetingAccountID,
			&i.OriginalTweetID,
			&i.CreatedAt,
			&i.OriginalTweetContent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRetweetsAndQuotesByOriginalTweetId = `-- name: GetRetweetsAndQuotesByOriginalTweetId :many
SELECT r.retweet_id, r.retweeting_account_id, r.original_tweet_id, r.created_at, t.content AS retweet_content
FROM retweets_and_quotes r
JOIN tweets t ON r.retweet_id = t.id
WHERE r.original_tweet_id = ?
ORDER BY r.created_at DESC
LIMIT ? OFFSET ?
`

type GetRetweetsAndQuotesByOriginalTweetIdParams struct {
	OriginalTweetID uint64
	Limit           int32
	Offset          int32
}

type GetRetweetsAndQuotesByOriginalTweetIdRow struct {
	RetweetID           uint64
	RetweetingAccountID string
	OriginalTweetID     uint64
	CreatedAt           time.Time
	RetweetContent      sql.NullString
}

func (q *Queries) GetRetweetsAndQuotesByOriginalTweetId(ctx context.Context, arg GetRetweetsAndQuotesByOriginalTweetIdParams) ([]GetRetweetsAndQuotesByOriginalTweetIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getRetweetsAndQuotesByOriginalTweetId, arg.OriginalTweetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRetweetsAndQuotesByOriginalTweetIdRow
	for rows.Next() {
		var i GetRetweetsAndQuotesByOriginalTweetIdRow
		if err := rows.Scan(
			&i.RetweetID,
			&i.RetweetingAccountID,
			&i.OriginalTweetID,
			&i.CreatedAt,
			&i.RetweetContent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSentFollowRequestCount = `-- name: GetSentFollowRequestCount :one
SELECT COUNT(*) FROM follow_requests
WHERE requester_account_id = ?
`

func (q *Queries) GetSentFollowRequestCount(ctx context.Context, requesterAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSentFollowRequestCount, requesterAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSentFollowRequests = `-- name: GetSentFollowRequests :many
SELECT requestee_account_id
FROM follow_requests
WHERE requester_account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetSentFollowRequestsParams struct {
	RequesterAccountID string
	Limit              int32
	Offset             int32
}

func (q *Queries) GetSentFollowRequests(ctx context.Context, arg GetSentFollowRequestsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSentFollowRequests, arg.RequesterAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var requestee_account_id string
		if err := rows.Scan(&requestee_account_id); err != nil {
			return nil, err
		}
		items = append(items, requestee_account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingsByAccountId = `-- name: GetSettingsByAccountId :one
SELECT account_id, is_private, created_at, updated_at FROM settings
WHERE account_id = ?
`

func (q *Queries) GetSettingsByAccountId(ctx context.Context, accountID string) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSettingsByAccountId, accountID)
	var i Setting
	err := row.Scan(
		&i.AccountID,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTrendingTweets = `-- name: GetTrendingTweets :many
SELECT id, account_id, is_pinned, content, code, likes_count, replies_count, retweets_count, is_retweet, is_reply, is_quote, engagement_score, media, created_at, updated_at FROM tweets
ORDER BY engagement_score DESC
LIMIT ?
`

func (q *Queries) GetTrendingTweets(ctx context.Context, limit int32) ([]Tweet, error) {
	rows, err := q.db.QueryContext(ctx, getTrendingTweets, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweet
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTweetById = `-- name: GetTweetById :one
SELECT id, account_id, is_pinned, content, code, likes_count, replies_count, retweets_count, is_retweet, is_reply, is_quote, engagement_score, media, created_at, updated_at FROM tweets WHERE id = ?
`

func (q *Queries) GetTweetById(ctx context.Context, id uint64) (Tweet, error) {
	row := q.db.QueryRowContext(ctx, getTweetById, id)
	var i Tweet
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.IsPinned,
		&i.Content,
		&i.Code,
		&i.LikesCount,
		&i.RepliesCount,
		&i.RetweetsCount,
		&i.IsRetweet,
		&i.IsReply,
		&i.IsQuote,
		&i.EngagementScore,
		&i.Media,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTweetCountByAccountId = `-- name: GetTweetCountByAccountId :one
SELECT COUNT(*) FROM tweets WHERE account_id = ?
`

func (q *Queries) GetTweetCountByAccountId(ctx context.Context, accountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTweetCountByAccountId, accountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTweetCountByHashtagId = `-- name: GetTweetCountByHashtagId :one
SELECT COUNT(DISTINCT tweet_id)
FROM tweet_hashtags
WHERE hashtag_id = ?
`

func (q *Queries) GetTweetCountByHashtagId(ctx context.Context, hashtagID uint64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTweetCountByHashtagId, hashtagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTweetsByAccountId = `-- name: GetTweetsByAccountId :many
SELECT id, account_id, is_pinned, content, code, likes_count, replies_count, retweets_count, is_retweet, is_reply, is_quote, engagement_score, media, created_at, updated_at FROM tweets
WHERE account_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetTweetsByAccountIdParams struct {
	AccountID string
	Limit     int32
	Offset    int32
}

func (q *Queries) GetTweetsByAccountId(ctx context.Context, arg GetTweetsByAccountIdParams) ([]Tweet, error) {
	rows, err := q.db.QueryContext(ctx, getTweetsByAccountId, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweet
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTweetsByHashtagId = `-- name: GetTweetsByHashtagId :many
SELECT t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_retweet, t.is_reply, t.is_quote, t.engagement_score, t.media, t.created_at, t.updated_at
FROM tweets t
JOIN tweet_hashtags th ON t.id = th.tweet_id
WHERE th.hashtag_id = ?
ORDER BY t.created_at DESC
LIMIT ? OFFSET ?
`

type GetTweetsByHashtagIdParams struct {
	HashtagID uint64
	Limit     int32
	Offset    int32
}

func (q *Queries) GetTweetsByHashtagId(ctx context.Context, arg GetTweetsByHashtagIdParams) ([]Tweet, error) {
	rows, err := q.db.QueryContext(ctx, getTweetsByHashtagId, arg.HashtagID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweet
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTweetsByLabel = `-- name: GetTweetsByLabel :many
SELECT t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_retweet, t.is_reply, t.is_quote, t.engagement_score, t.media, t.created_at, t.updated_at FROM tweets t
JOIN labels l ON t.id = l.tweet_id
WHERE l.label1 = ? OR l.label2 = ? OR l.label3 = ?
ORDER BY t.created_at DESC
LIMIT ? OFFSET ?
`

type GetTweetsByLabelParams struct {
	Label1 string
	Label2 sql.NullString
	Label3 sql.NullString
	Limit  int32
	Offset int32
}

func (q *Queries) GetTweetsByLabel(ctx context.Context, arg GetTweetsByLabelParams) ([]Tweet, error) {
	rows, err := q.db.QueryContext(ctx, getTweetsByLabel,
		arg.Label1,
		arg.Label2,
		arg.Label3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweet
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTweetsWithoutLabels = `-- name: GetTweetsWithoutLabels :many
SELECT t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_retweet, t.is_reply, t.is_quote, t.engagement_score, t.media, t.created_at, t.updated_at FROM tweets t
LEFT JOIN labels l ON t.id = l.tweet_id
WHERE l.tweet_id IS NULL
ORDER BY t.created_at DESC
LIMIT ? OFFSET ?
`

type GetTweetsWithoutLabelsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetTweetsWithoutLabels(ctx context.Context, arg GetTweetsWithoutLabelsParams) ([]Tweet, error) {
	rows, err := q.db.QueryContext(ctx, getTweetsWithoutLabels, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweet
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadMessageCountForUser = `-- name: GetUnreadMessageCountForUser :one
SELECT COUNT(*) FROM messages
WHERE recipient_account_id = ? AND is_read = FALSE
`

func (q *Queries) GetUnreadMessageCountForUser(ctx context.Context, recipientAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUnreadMessageCountForUser, recipientAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnreadMessagesForUser = `-- name: GetUnreadMessagesForUser :many
SELECT id, sender_account_id, recipient_account_id, content, is_read, created_at, updated_at FROM messages
WHERE recipient_account_id = ? AND is_read = FALSE
ORDER BY created_at DESC
`

func (q *Queries) GetUnreadMessagesForUser(ctx context.Context, recipientAccountID string) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadMessagesForUser, recipientAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderAccountID,
			&i.RecipientAccountID,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadNotificationCountByRecipientId = `-- name: GetUnreadNotificationCountByRecipientId :one
SELECT COUNT(*) FROM notifications
WHERE recipient_account_id = ? AND is_read = FALSE
`

func (q *Queries) GetUnreadNotificationCountByRecipientId(ctx context.Context, recipientAccountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUnreadNotificationCountByRecipientId, recipientAccountID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnreadNotificationsByRecipientId = `-- name: GetUnreadNotificationsByRecipientId :many
SELECT id, sender_account_id, recipient_account_id, type, content, is_read, created_at, updated_at FROM notifications
WHERE recipient_account_id = ? AND is_read = FALSE
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetUnreadNotificationsByRecipientIdParams struct {
	RecipientAccountID string
	Limit              int32
	Offset             int32
}

func (q *Queries) GetUnreadNotificationsByRecipientId(ctx context.Context, arg GetUnreadNotificationsByRecipientIdParams) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadNotificationsByRecipientId, arg.RecipientAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.SenderAccountID,
			&i.RecipientAccountID,
			&i.Type,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementLikesCount = `-- name: IncrementLikesCount :exec
UPDATE tweets SET likes_count = likes_count + 1 WHERE id = ?
`

func (q *Queries) IncrementLikesCount(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, incrementLikesCount, id)
	return err
}

const incrementRepliesCount = `-- name: IncrementRepliesCount :exec
UPDATE tweets SET replies_count = replies_count + 1 WHERE id = ?
`

func (q *Queries) IncrementRepliesCount(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, incrementRepliesCount, id)
	return err
}

const incrementRetweetsCount = `-- name: IncrementRetweetsCount :exec
UPDATE tweets SET retweets_count = retweets_count + 1 WHERE id = ?
`

func (q *Queries) IncrementRetweetsCount(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, incrementRetweetsCount, id)
	return err
}

const markAllMessagesAsRead = `-- name: MarkAllMessagesAsRead :exec
UPDATE messages
SET is_read = TRUE
WHERE recipient_account_id = ? AND is_read = FALSE
`

func (q *Queries) MarkAllMessagesAsRead(ctx context.Context, recipientAccountID string) error {
	_, err := q.db.ExecContext(ctx, markAllMessagesAsRead, recipientAccountID)
	return err
}

const markAllNotificationsAsRead = `-- name: MarkAllNotificationsAsRead :exec
UPDATE notifications
SET is_read = TRUE
WHERE recipient_account_id = ? AND is_read = FALSE
`

func (q *Queries) MarkAllNotificationsAsRead(ctx context.Context, recipientAccountID string) error {
	_, err := q.db.ExecContext(ctx, markAllNotificationsAsRead, recipientAccountID)
	return err
}

const markMessageAsRead = `-- name: MarkMessageAsRead :exec
UPDATE messages
SET is_read = TRUE
WHERE id = ? AND recipient_account_id = ?
`

type MarkMessageAsReadParams struct {
	ID                 uint32
	RecipientAccountID string
}

func (q *Queries) MarkMessageAsRead(ctx context.Context, arg MarkMessageAsReadParams) error {
	_, err := q.db.ExecContext(ctx, markMessageAsRead, arg.ID, arg.RecipientAccountID)
	return err
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
UPDATE notifications
SET is_read = TRUE
WHERE id = ? AND recipient_account_id = ?
`

type MarkNotificationAsReadParams struct {
	ID                 uint32
	RecipientAccountID string
}

func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) error {
	_, err := q.db.ExecContext(ctx, markNotificationAsRead, arg.ID, arg.RecipientAccountID)
	return err
}

const rejectFollowRequest = `-- name: RejectFollowRequest :exec
DELETE FROM follow_requests
WHERE requester_account_id = ? AND requestee_account_id = ?
`

type RejectFollowRequestParams struct {
	RequesterAccountID string
	RequesteeAccountID string
}

func (q *Queries) RejectFollowRequest(ctx context.Context, arg RejectFollowRequestParams) error {
	_, err := q.db.ExecContext(ctx, rejectFollowRequest, arg.RequesterAccountID, arg.RequesteeAccountID)
	return err
}

const searchAccountsByUserId = `-- name: SearchAccountsByUserId :many
SELECT id, user_id, user_name, created_at, updated_at FROM accounts
WHERE user_id LIKE CONCAT('%', ?, '%')
ORDER BY user_id
LIMIT ? OFFSET ?
`

type SearchAccountsByUserIdParams struct {
	CONCAT interface{}
	Limit  int32
	Offset int32
}

func (q *Queries) SearchAccountsByUserId(ctx context.Context, arg SearchAccountsByUserIdParams) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, searchAccountsByUserId, arg.CONCAT, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAccountsByUserName = `-- name: SearchAccountsByUserName :many
SELECT id, user_id, user_name, created_at, updated_at FROM accounts
WHERE user_name LIKE CONCAT('%', ?, '%')
ORDER BY user_name
LIMIT ? OFFSET ?
`

type SearchAccountsByUserNameParams struct {
	CONCAT interface{}
	Limit  int32
	Offset int32
}

func (q *Queries) SearchAccountsByUserName(ctx context.Context, arg SearchAccountsByUserNameParams) ([]Account, error) {
	rows, err := q.db.QueryContext(ctx, searchAccountsByUserName, arg.CONCAT, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchHashtags = `-- name: SearchHashtags :many
SELECT id, tag, created_at FROM hashtags
WHERE tag LIKE CONCAT('%', ?, '%')
ORDER BY tag ASC
LIMIT ?
`

type SearchHashtagsParams struct {
	CONCAT interface{}
	Limit  int32
}

func (q *Queries) SearchHashtags(ctx context.Context, arg SearchHashtagsParams) ([]Hashtag, error) {
	rows, err := q.db.QueryContext(ctx, searchHashtags, arg.CONCAT, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hashtag
	for rows.Next() {
		var i Hashtag
		if err := rows.Scan(&i.ID, &i.Tag, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMessages = `-- name: SearchMessages :many
SELECT id, sender_account_id, recipient_account_id, content, is_read, created_at, updated_at FROM messages
WHERE (sender_account_id = ? OR recipient_account_id = ?)
    AND content LIKE ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchMessagesParams struct {
	SenderAccountID    string
	RecipientAccountID string
	Content            sql.NullString
	Limit              int32
	Offset             int32
}

func (q *Queries) SearchMessages(ctx context.Context, arg SearchMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, searchMessages,
		arg.SenderAccountID,
		arg.RecipientAccountID,
		arg.Content,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SenderAccountID,
			&i.RecipientAccountID,
			&i.Content,
			&i.IsRead,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTweets = `-- name: SearchTweets :many
SELECT id, account_id, is_pinned, content, code, likes_count, replies_count, retweets_count, is_retweet, is_reply, is_quote, engagement_score, media, created_at, updated_at FROM tweets
WHERE content LIKE ? OR code LIKE ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type SearchTweetsParams struct {
	Content sql.NullString
	Code    sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchTweets(ctx context.Context, arg SearchTweetsParams) ([]Tweet, error) {
	rows, err := q.db.QueryContext(ctx, searchTweets,
		arg.Content,
		arg.Code,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweet
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTweetAsPinned = `-- name: SetTweetAsPinned :exec
UPDATE tweets
SET is_pinned = TRUE
WHERE id = ? AND account_id = ?
`

type SetTweetAsPinnedParams struct {
	ID        uint64
	AccountID string
}

func (q *Queries) SetTweetAsPinned(ctx context.Context, arg SetTweetAsPinnedParams) error {
	_, err := q.db.ExecContext(ctx, setTweetAsPinned, arg.ID, arg.AccountID)
	return err
}

const unpinTweet = `-- name: UnpinTweet :exec
UPDATE tweets
SET is_pinned = FALSE
WHERE id = ? AND account_id = ?
`

type UnpinTweetParams struct {
	ID        uint64
	AccountID string
}

func (q *Queries) UnpinTweet(ctx context.Context, arg UnpinTweetParams) error {
	_, err := q.db.ExecContext(ctx, unpinTweet, arg.ID, arg.AccountID)
	return err
}

const updateAccountUserName = `-- name: UpdateAccountUserName :exec
UPDATE accounts
SET user_name = ?
WHERE id = ?
`

type UpdateAccountUserNameParams struct {
	UserName string
	ID       string
}

func (q *Queries) UpdateAccountUserName(ctx context.Context, arg UpdateAccountUserNameParams) error {
	_, err := q.db.ExecContext(ctx, updateAccountUserName, arg.UserName, arg.ID)
	return err
}

const updateBannerImageUrl = `-- name: UpdateBannerImageUrl :exec
UPDATE profiles
SET banner_image_url = ?
WHERE account_id = ?
`

type UpdateBannerImageUrlParams struct {
	BannerImageUrl sql.NullString
	AccountID      string
}

func (q *Queries) UpdateBannerImageUrl(ctx context.Context, arg UpdateBannerImageUrlParams) error {
	_, err := q.db.ExecContext(ctx, updateBannerImageUrl, arg.BannerImageUrl, arg.AccountID)
	return err
}

const updateEngagementScore = `-- name: UpdateEngagementScore :exec
UPDATE tweets
SET engagement_score = likes_count + replies_count + retweets_count
WHERE id = ?
`

func (q *Queries) UpdateEngagementScore(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, updateEngagementScore, id)
	return err
}

const updateHashtagCreatedAt = `-- name: UpdateHashtagCreatedAt :exec
UPDATE hashtags
SET created_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) UpdateHashtagCreatedAt(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, updateHashtagCreatedAt, id)
	return err
}

const updateInterestScore = `-- name: UpdateInterestScore :exec
UPDATE interests
SET
    news_score = COALESCE(?, news_score),
    politics_score = COALESCE(?, politics_score),
    economics_score = COALESCE(?, economics_score),
    health_score = COALESCE(?, health_score),
    sports_score = COALESCE(?, sports_score),
    entertainment_score = COALESCE(?, entertainment_score),
    art_score = COALESCE(?, art_score),
    cooking_score = COALESCE(?, cooking_score),
    travel_score = COALESCALE(?, travel_score),
    fashion_score = COALESCE(?, fashion_score),
    beauty_score = COALESCE(?, beauty_score),
    pets_score = COALESCE(?, pets_score),
    parenting_score = COALESCE(?, parenting_score),
    education_score = COALESCE(?, education_score),
    environment_score = COALESCE(?, environment_score),
    climate_score = COALESCE(?, climate_score),
    space_score = COALESCE(?, space_score),
    mental_health_score = COALESCE(?, mental_health_score),
    fitness_score = COALESCE(?, fitness_score),
    reading_score = COALESCE(?, reading_score),
    history_score = COALESCE(?, history_score),
    philosophy_score = COALESCE(?, philosophy_score),
    religion_score = COALESCE(?, religion_score),
    culture_score = COALESCE(?, culture_score),
    volunteering_score = COALESCE(?, volunteer_score),
    social_issues_score = COALESCE(?, social_issues_score),
    law_score = COALESCE(?, law_score),
    taxes_score = COALESCE(?, taxes_score),
    investment_score = COALESCE(?, investment_score),
    real_estate_score = COALESCE(?, real_estate_score),
    diy_score = COALESCE(?, diy_score),
    gardening_score = COALESCE(?, gardening_score),
    interior_design_score = COALESCE(?, interior_design_score),
    automotive_score = COALESCE(?, automotive_score),
    gaming_score = COALESCE(?, gaming_score),
    anime_manga_score = COALESCE(?, anime_manga_score),
    creative_works_score = COALESCE(?, creative_works_score),
    photography_video_score = COALESCE(?, photography_video_score),
    media_score = COALESCE(?, media_score),
    marketing_score = COALESCE(?, marketing_score),
    branding_score = COALESCE(?, branding_score),
    entrepreneurship_score = COALESCE(?, entrepreneurship_score),
    remote_work_score = COALESCE(?, remote_work_score),
    data_science_score = COALESCE(?, data_science_score),
    iot_score = COALESCE(?, iot_score),
    robotics_engineering_score = COALESCE(?, robotics_engineering_score),
    biotechnology_score = COALESCE(?, biotechnology_score),
    nanotechnology_score = COALESCE(?, nanotechnology_score),
    energy_technology_score = COALESCE(?, energy_technology_score),
    archaeology_score = COALESCE(?, archaeology_score),
    psychology_score = COALESCE(?, psychology_score),
    sociology_score = COALESCE(?, sociology_score),
    anthropology_score = COALESCE(?, anthropology_score),
    geography_score = COALESCE(?, geography_score),
    geology_score = COALESCE(?, geology_score),
    meteorology_score = COALESCE(?, meteorology_score),
    disaster_emergency_management_score = COALESCE(?, disaster_emergency_management_score),
    urban_planning_score = COALESCE(?, urban_planning_score),
    architecture_score = COALESCE(?, architecture_score),
    agriculture_score = COALESCE(?, agriculture_score),
    nutrition_science_score = COALESCE(?, nutrition_science_score),
    sleep_science_score = COALESCE(?, sleep_science_score),
    productivity_score = COALESCE(?, productivity_score),
    leadership_score = COALESCE(?, leadership_score),
    international_relations_score = COALESCE(?, international_relations_score),
    future_predictions_score = COALESCE(?, future_predictions_score),
    events_score = COALESCE(?, events_score),
    community_score = COALESCE(?, community_score),
    trends_score = COALESCE(?, trends_score),
    lifestyle_score = COALESCE(?, lifestyle_score),
    software_development_score = COALESCE(?, software_development_score),
    programming_languages_score = COALESCE(?, programming_languages_score),
    web_development_score = COALESCE(?, web_development_score),
    mobile_app_development_score = COALESCE(?, mobile_app_development_score),
    debugging_techniques_score = COALESCE(?, debugging_techniques_score),
    algorithms_mathematics_score = COALESCE(?, algorithms_mathematics_score),
    database_design_score = COALESCE(?, database_design_score),
    cloud_computing_score = COALESCE(?, cloud_computing_score),
    server_management_score = COALESCE(?, server_management_score),
    network_security_score = COALESCE(?, network_security_score),
    cryptography_score = COALESCE(?, cryptography_score),
    artificial_intelligence_score = COALESCE(?, artificial_intelligence_score),
    machine_learning_score = COALESCE(?, machine_learning_score),
    deep_learning_score = COALESCE(?, deep_learning_score),
    computer_vision_score = COALESCE(?, computer_vision_score),
    natural_language_processing_score = COALESCE(?, natural_language_processing_score),
    blockchain_technology_score = COALESCE(?, blockchain_technology_score),
    quantum_computing_score = COALESCE(?, quantum_computing_score),
    edge_computing_score = COALESCE(?, edge_computing_score),
    microservices_architecture_score = COALESCE(?, microservices_architecture_score),
    devops_score = COALESCE(?, devops_score),
    container_technology_score = COALESCE(?, container_technology_score),
    ci_cd_score = COALESCE(?, ci_cd_score),
    test_automation_score = COALESCE(?, test_automation_score),
    ux_ui_design_score = COALESCE(?, ux_ui_design_score),
    agile_development_methodologies_score = COALESCE(?, agile_development_methodologies_score),
    open_source_score = COALESCE(?, open_source_score),
    version_control_score = COALESCE(?, version_control_score),
    api_design_score = COALESCE(?, api_design_score),
    performance_optimization_score = COALESCE(?, performance_optimization_score)
WHERE account_id = ?
`

type UpdateInterestScoreParams struct {
	NewsScore                          sql.NullInt16
	PoliticsScore                      sql.NullInt16
	EconomicsScore                     sql.NullInt16
	HealthScore                        sql.NullInt16
	SportsScore                        sql.NullInt16
	EntertainmentScore                 sql.NullInt16
	ArtScore                           sql.NullInt16
	CookingScore                       sql.NullInt16
	Coalescale                         interface{}
	FashionScore                       sql.NullInt16
	BeautyScore                        sql.NullInt16
	PetsScore                          sql.NullInt16
	ParentingScore                     sql.NullInt16
	EducationScore                     sql.NullInt16
	EnvironmentScore                   sql.NullInt16
	ClimateScore                       sql.NullInt16
	SpaceScore                         sql.NullInt16
	MentalHealthScore                  sql.NullInt16
	FitnessScore                       sql.NullInt16
	ReadingScore                       sql.NullInt16
	HistoryScore                       sql.NullInt16
	PhilosophyScore                    sql.NullInt16
	ReligionScore                      sql.NullInt16
	CultureScore                       sql.NullInt16
	VolunteeringScore                  sql.NullInt16
	SocialIssuesScore                  sql.NullInt16
	LawScore                           sql.NullInt16
	TaxesScore                         sql.NullInt16
	InvestmentScore                    sql.NullInt16
	RealEstateScore                    sql.NullInt16
	DiyScore                           sql.NullInt16
	GardeningScore                     sql.NullInt16
	InteriorDesignScore                sql.NullInt16
	AutomotiveScore                    sql.NullInt16
	GamingScore                        sql.NullInt16
	AnimeMangaScore                    sql.NullInt16
	CreativeWorksScore                 sql.NullInt16
	PhotographyVideoScore              sql.NullInt16
	MediaScore                         sql.NullInt16
	MarketingScore                     sql.NullInt16
	BrandingScore                      sql.NullInt16
	EntrepreneurshipScore              sql.NullInt16
	RemoteWorkScore                    sql.NullInt16
	DataScienceScore                   sql.NullInt16
	IotScore                           sql.NullInt16
	RoboticsEngineeringScore           sql.NullInt16
	BiotechnologyScore                 sql.NullInt16
	NanotechnologyScore                sql.NullInt16
	EnergyTechnologyScore              sql.NullInt16
	ArchaeologyScore                   sql.NullInt16
	PsychologyScore                    sql.NullInt16
	SociologyScore                     sql.NullInt16
	AnthropologyScore                  sql.NullInt16
	GeographyScore                     sql.NullInt16
	GeologyScore                       sql.NullInt16
	MeteorologyScore                   sql.NullInt16
	DisasterEmergencyManagementScore   sql.NullInt16
	UrbanPlanningScore                 sql.NullInt16
	ArchitectureScore                  sql.NullInt16
	AgricultureScore                   sql.NullInt16
	NutritionScienceScore              sql.NullInt16
	SleepScienceScore                  sql.NullInt16
	ProductivityScore                  sql.NullInt16
	LeadershipScore                    sql.NullInt16
	InternationalRelationsScore        sql.NullInt16
	FuturePredictionsScore             sql.NullInt16
	EventsScore                        sql.NullInt16
	CommunityScore                     sql.NullInt16
	TrendsScore                        sql.NullInt16
	LifestyleScore                     sql.NullInt16
	SoftwareDevelopmentScore           sql.NullInt16
	ProgrammingLanguagesScore          sql.NullInt16
	WebDevelopmentScore                sql.NullInt16
	MobileAppDevelopmentScore          sql.NullInt16
	DebuggingTechniquesScore           sql.NullInt16
	AlgorithmsMathematicsScore         sql.NullInt16
	DatabaseDesignScore                sql.NullInt16
	CloudComputingScore                sql.NullInt16
	ServerManagementScore              sql.NullInt16
	NetworkSecurityScore               sql.NullInt16
	CryptographyScore                  sql.NullInt16
	ArtificialIntelligenceScore        sql.NullInt16
	MachineLearningScore               sql.NullInt16
	DeepLearningScore                  sql.NullInt16
	ComputerVisionScore                sql.NullInt16
	NaturalLanguageProcessingScore     sql.NullInt16
	BlockchainTechnologyScore          sql.NullInt16
	QuantumComputingScore              sql.NullInt16
	EdgeComputingScore                 sql.NullInt16
	MicroservicesArchitectureScore     sql.NullInt16
	DevopsScore                        sql.NullInt16
	ContainerTechnologyScore           sql.NullInt16
	CiCdScore                          sql.NullInt16
	TestAutomationScore                sql.NullInt16
	UxUiDesignScore                    sql.NullInt16
	AgileDevelopmentMethodologiesScore sql.NullInt16
	OpenSourceScore                    sql.NullInt16
	VersionControlScore                sql.NullInt16
	ApiDesignScore                     sql.NullInt16
	PerformanceOptimizationScore       sql.NullInt16
	AccountID                          string
}

func (q *Queries) UpdateInterestScore(ctx context.Context, arg UpdateInterestScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateInterestScore,
		arg.NewsScore,
		arg.PoliticsScore,
		arg.EconomicsScore,
		arg.HealthScore,
		arg.SportsScore,
		arg.EntertainmentScore,
		arg.ArtScore,
		arg.CookingScore,
		arg.Coalescale,
		arg.FashionScore,
		arg.BeautyScore,
		arg.PetsScore,
		arg.ParentingScore,
		arg.EducationScore,
		arg.EnvironmentScore,
		arg.ClimateScore,
		arg.SpaceScore,
		arg.MentalHealthScore,
		arg.FitnessScore,
		arg.ReadingScore,
		arg.HistoryScore,
		arg.PhilosophyScore,
		arg.ReligionScore,
		arg.CultureScore,
		arg.VolunteeringScore,
		arg.SocialIssuesScore,
		arg.LawScore,
		arg.TaxesScore,
		arg.InvestmentScore,
		arg.RealEstateScore,
		arg.DiyScore,
		arg.GardeningScore,
		arg.InteriorDesignScore,
		arg.AutomotiveScore,
		arg.GamingScore,
		arg.AnimeMangaScore,
		arg.CreativeWorksScore,
		arg.PhotographyVideoScore,
		arg.MediaScore,
		arg.MarketingScore,
		arg.BrandingScore,
		arg.EntrepreneurshipScore,
		arg.RemoteWorkScore,
		arg.DataScienceScore,
		arg.IotScore,
		arg.RoboticsEngineeringScore,
		arg.BiotechnologyScore,
		arg.NanotechnologyScore,
		arg.EnergyTechnologyScore,
		arg.ArchaeologyScore,
		arg.PsychologyScore,
		arg.SociologyScore,
		arg.AnthropologyScore,
		arg.GeographyScore,
		arg.GeologyScore,
		arg.MeteorologyScore,
		arg.DisasterEmergencyManagementScore,
		arg.UrbanPlanningScore,
		arg.ArchitectureScore,
		arg.AgricultureScore,
		arg.NutritionScienceScore,
		arg.SleepScienceScore,
		arg.ProductivityScore,
		arg.LeadershipScore,
		arg.InternationalRelationsScore,
		arg.FuturePredictionsScore,
		arg.EventsScore,
		arg.CommunityScore,
		arg.TrendsScore,
		arg.LifestyleScore,
		arg.SoftwareDevelopmentScore,
		arg.ProgrammingLanguagesScore,
		arg.WebDevelopmentScore,
		arg.MobileAppDevelopmentScore,
		arg.DebuggingTechniquesScore,
		arg.AlgorithmsMathematicsScore,
		arg.DatabaseDesignScore,
		arg.CloudComputingScore,
		arg.ServerManagementScore,
		arg.NetworkSecurityScore,
		arg.CryptographyScore,
		arg.ArtificialIntelligenceScore,
		arg.MachineLearningScore,
		arg.DeepLearningScore,
		arg.ComputerVisionScore,
		arg.NaturalLanguageProcessingScore,
		arg.BlockchainTechnologyScore,
		arg.QuantumComputingScore,
		arg.EdgeComputingScore,
		arg.MicroservicesArchitectureScore,
		arg.DevopsScore,
		arg.ContainerTechnologyScore,
		arg.CiCdScore,
		arg.TestAutomationScore,
		arg.UxUiDesignScore,
		arg.AgileDevelopmentMethodologiesScore,
		arg.OpenSourceScore,
		arg.VersionControlScore,
		arg.ApiDesignScore,
		arg.PerformanceOptimizationScore,
		arg.AccountID,
	)
	return err
}

const updateLabels = `-- name: UpdateLabels :exec
UPDATE labels
SET label1 = ?, label2 = ?, label3 = ?
WHERE tweet_id = ?
`

type UpdateLabelsParams struct {
	Label1  string
	Label2  sql.NullString
	Label3  sql.NullString
	TweetID uint64
}

func (q *Queries) UpdateLabels(ctx context.Context, arg UpdateLabelsParams) error {
	_, err := q.db.ExecContext(ctx, updateLabels,
		arg.Label1,
		arg.Label2,
		arg.Label3,
		arg.TweetID,
	)
	return err
}

const updateProfileBio = `-- name: UpdateProfileBio :exec
UPDATE profiles
SET bio = ?
WHERE account_id = ?
`

type UpdateProfileBioParams struct {
	Bio       sql.NullString
	AccountID string
}

func (q *Queries) UpdateProfileBio(ctx context.Context, arg UpdateProfileBioParams) error {
	_, err := q.db.ExecContext(ctx, updateProfileBio, arg.Bio, arg.AccountID)
	return err
}

const updateProfileImageUrl = `-- name: UpdateProfileImageUrl :exec
UPDATE profiles
SET profile_image_url = ?
WHERE account_id = ?
`

type UpdateProfileImageUrlParams struct {
	ProfileImageUrl sql.NullString
	AccountID       string
}

func (q *Queries) UpdateProfileImageUrl(ctx context.Context, arg UpdateProfileImageUrlParams) error {
	_, err := q.db.ExecContext(ctx, updateProfileImageUrl, arg.ProfileImageUrl, arg.AccountID)
	return err
}

const updateSettingsPrivacy = `-- name: UpdateSettingsPrivacy :exec
UPDATE settings
SET is_private = ?
WHERE account_id = ?
`

type UpdateSettingsPrivacyParams struct {
	IsPrivate bool
	AccountID string
}

func (q *Queries) UpdateSettingsPrivacy(ctx context.Context, arg UpdateSettingsPrivacyParams) error {
	_, err := q.db.ExecContext(ctx, updateSettingsPrivacy, arg.IsPrivate, arg.AccountID)
	return err
}

const updateTweetCode = `-- name: UpdateTweetCode :exec
UPDATE tweets
SET code = ?
WHERE id = ? AND account_id = ?
`

type UpdateTweetCodeParams struct {
	Code      sql.NullString
	ID        uint64
	AccountID string
}

func (q *Queries) UpdateTweetCode(ctx context.Context, arg UpdateTweetCodeParams) error {
	_, err := q.db.ExecContext(ctx, updateTweetCode, arg.Code, arg.ID, arg.AccountID)
	return err
}

const updateTweetContent = `-- name: UpdateTweetContent :exec
UPDATE tweets
SET content = ?
WHERE id = ? AND account_id = ?
`

type UpdateTweetContentParams struct {
	Content   sql.NullString
	ID        uint64
	AccountID string
}

func (q *Queries) UpdateTweetContent(ctx context.Context, arg UpdateTweetContentParams) error {
	_, err := q.db.ExecContext(ctx, updateTweetContent, arg.Content, arg.ID, arg.AccountID)
	return err
}
