// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: replies.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const createReply = `-- name: CreateReply :exec
INSERT INTO replies (reply_id, parent_reply_id, replying_account_id)
VALUES ($1, $2, $3)
`

type CreateReplyParams struct {
	ReplyID           int64
	ParentReplyID     sql.NullInt64
	ReplyingAccountID string
}

func (q *Queries) CreateReply(ctx context.Context, arg CreateReplyParams) error {
	_, err := q.db.ExecContext(ctx, createReply, arg.ReplyID, arg.ParentReplyID, arg.ReplyingAccountID)
	return err
}

const getReplyThread = `-- name: GetReplyThread :many



WITH RECURSIVE reply_thread AS (
    SELECT reply_id, original_tweet_id, parent_reply_id, replying_account_id, created_at FROM replies r0 WHERE r0.reply_id = $1
    UNION ALL
    SELECT r.reply_id, r.original_tweet_id, r.parent_reply_id, r.replying_account_id, r.created_at FROM replies r
    JOIN reply_thread rt ON r.parent_reply_id = rt.reply_id
)
SELECT rt.reply_id, rt.original_tweet_id, rt.parent_reply_id, rt.replying_account_id, rt.created_at, t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_reply, t.is_quote, t.media, t.created_at, t.updated_at
FROM reply_thread rt
JOIN tweets t ON rt.tweet_id = t.id
ORDER BY rt.created_at ASC
`

type GetReplyThreadRow struct {
	ReplyID           int64
	OriginalTweetID   int64
	ParentReplyID     sql.NullInt64
	ReplyingAccountID string
	CreatedAt         time.Time
	ID                int64
	AccountID         string
	IsPinned          bool
	Content           sql.NullString
	Code              sql.NullString
	LikesCount        int32
	RepliesCount      int32
	RetweetsCount     int32
	IsReply           bool
	IsQuote           bool
	Media             pqtype.NullRawMessage
	CreatedAt_2       time.Time
	UpdatedAt         time.Time
}

// -- name: GetRepliesByOriginalTweetID :many
// SELECT r.*, t.content AS reply_content, a.user_name AS replier_name
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN accounts a ON r.replying_account_id = a.id
// WHERE r.original_tweet_id = $1
// ORDER BY r.created_at ASC
// LIMIT $2 OFFSET $3;
// -- name: GetRepliesByParentReplyID :many
// SELECT r.*, t.content AS reply_content, a.user_name AS replier_name
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN accounts a ON r.replying_account_id = a.id
// WHERE r.parent_reply_id = $1
// ORDER BY r.created_at ASC
// LIMIT $2 OFFSET $3;
// -- name: GetRepliesByAccountID :many
// SELECT r.*, t.content AS reply_content, ot.content AS original_tweet_content
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN tweets ot ON r.original_tweet_id = ot.id
// WHERE r.replying_account_id = $1
// ORDER BY r.created_at DESC
// LIMIT $2 OFFSET $3;
func (q *Queries) GetReplyThread(ctx context.Context, replyID int64) ([]GetReplyThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, getReplyThread, replyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReplyThreadRow
	for rows.Next() {
		var i GetReplyThreadRow
		if err := rows.Scan(
			&i.ReplyID,
			&i.OriginalTweetID,
			&i.ParentReplyID,
			&i.ReplyingAccountID,
			&i.CreatedAt,
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsReply,
			&i.IsQuote,
			&i.Media,
			&i.CreatedAt_2,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
