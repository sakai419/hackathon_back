// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: replies.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const createReply = `-- name: CreateReply :exec
INSERT INTO replies (original_tweet_id, parent_reply_id, replying_account_id)
VALUES ($1, $2, $3)
`

type CreateReplyParams struct {
	OriginalTweetID   int64
	ParentReplyID     sql.NullInt64
	ReplyingAccountID string
}

func (q *Queries) CreateReply(ctx context.Context, arg CreateReplyParams) error {
	_, err := q.db.ExecContext(ctx, createReply, arg.OriginalTweetID, arg.ParentReplyID, arg.ReplyingAccountID)
	return err
}

const deleteReply = `-- name: DeleteReply :exec
DELETE FROM replies WHERE tweet_id = $1
`

func (q *Queries) DeleteReply(ctx context.Context, tweetID int64) error {
	_, err := q.db.ExecContext(ctx, deleteReply, tweetID)
	return err
}

const getReplyByID = `-- name: GetReplyByID :one
SELECT tweet_id, original_tweet_id, parent_reply_id, replying_account_id, created_at FROM replies WHERE tweet_id = $1
`

func (q *Queries) GetReplyByID(ctx context.Context, tweetID int64) (Reply, error) {
	row := q.db.QueryRowContext(ctx, getReplyByID, tweetID)
	var i Reply
	err := row.Scan(
		&i.TweetID,
		&i.OriginalTweetID,
		&i.ParentReplyID,
		&i.ReplyingAccountID,
		&i.CreatedAt,
	)
	return i, err
}

const getReplyCount = `-- name: GetReplyCount :one



SELECT COUNT(*) FROM replies WHERE original_tweet_id = $1
`

// -- name: GetRepliesByOriginalTweetID :many
// SELECT r.*, t.content AS reply_content, a.user_name AS replier_name
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN accounts a ON r.replying_account_id = a.id
// WHERE r.original_tweet_id = $1
// ORDER BY r.created_at ASC
// LIMIT $2 OFFSET $3;
// -- name: GetRepliesByParentReplyID :many
// SELECT r.*, t.content AS reply_content, a.user_name AS replier_name
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN accounts a ON r.replying_account_id = a.id
// WHERE r.parent_reply_id = $1
// ORDER BY r.created_at ASC
// LIMIT $2 OFFSET $3;
// -- name: GetRepliesByAccountID :many
// SELECT r.*, t.content AS reply_content, ot.content AS original_tweet_content
// FROM replies r
// JOIN tweets t ON r.reply_id = t.id
// JOIN tweets ot ON r.original_tweet_id = ot.id
// WHERE r.replying_account_id = $1
// ORDER BY r.created_at DESC
// LIMIT $2 OFFSET $3;
func (q *Queries) GetReplyCount(ctx context.Context, originalTweetID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getReplyCount, originalTweetID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getReplyThread = `-- name: GetReplyThread :many
WITH RECURSIVE reply_thread AS (
    SELECT tweet_id, original_tweet_id, parent_reply_id, replying_account_id, created_at FROM replies r0 WHERE r0.tweet_id = $1
    UNION ALL
    SELECT r.tweet_id, r.original_tweet_id, r.parent_reply_id, r.replying_account_id, r.created_at FROM replies r
    JOIN reply_thread rt ON r.parent_reply_id = rt.tweet_id
)
SELECT rt.tweet_id, rt.original_tweet_id, rt.parent_reply_id, rt.replying_account_id, rt.created_at, t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_retweet, t.is_reply, t.is_quote, t.engagement_score, t.media, t.created_at, t.updated_at
FROM reply_thread rt
JOIN tweets t ON rt.tweet_id = t.id
ORDER BY rt.created_at ASC
`

type GetReplyThreadRow struct {
	TweetID           int64
	OriginalTweetID   int64
	ParentReplyID     sql.NullInt64
	ReplyingAccountID string
	CreatedAt         time.Time
	ID                int64
	AccountID         string
	IsPinned          bool
	Content           sql.NullString
	Code              sql.NullString
	LikesCount        int32
	RepliesCount      int32
	RetweetsCount     int32
	IsRetweet         bool
	IsReply           bool
	IsQuote           bool
	EngagementScore   int32
	Media             pqtype.NullRawMessage
	CreatedAt_2       time.Time
	UpdatedAt         time.Time
}

func (q *Queries) GetReplyThread(ctx context.Context, tweetID int64) ([]GetReplyThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, getReplyThread, tweetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReplyThreadRow
	for rows.Next() {
		var i GetReplyThreadRow
		if err := rows.Scan(
			&i.TweetID,
			&i.OriginalTweetID,
			&i.ParentReplyID,
			&i.ReplyingAccountID,
			&i.CreatedAt,
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt_2,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
