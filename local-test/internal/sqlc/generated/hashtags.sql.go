// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: hashtags.sql

package sqlcgen

import (
	"context"
)

const createHashtag = `-- name: CreateHashtag :exec
INSERT INTO hashtags (tag) VALUES (?)
ON DUPLICATE KEY UPDATE id = LAST_INSERT_ID(id)
`

func (q *Queries) CreateHashtag(ctx context.Context, tag string) error {
	_, err := q.db.ExecContext(ctx, createHashtag, tag)
	return err
}

const deleteHashtag = `-- name: DeleteHashtag :exec
DELETE FROM hashtags WHERE id = ?
`

func (q *Queries) DeleteHashtag(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, deleteHashtag, id)
	return err
}

const getAllHashtags = `-- name: GetAllHashtags :many
SELECT id, tag, created_at FROM hashtags
ORDER BY tag ASC
LIMIT ? OFFSET ?
`

type GetAllHashtagsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetAllHashtags(ctx context.Context, arg GetAllHashtagsParams) ([]Hashtag, error) {
	rows, err := q.db.QueryContext(ctx, getAllHashtags, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hashtag
	for rows.Next() {
		var i Hashtag
		if err := rows.Scan(&i.ID, &i.Tag, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHashtagById = `-- name: GetHashtagById :one
SELECT id, tag, created_at FROM hashtags WHERE id = ?
`

func (q *Queries) GetHashtagById(ctx context.Context, id uint64) (Hashtag, error) {
	row := q.db.QueryRowContext(ctx, getHashtagById, id)
	var i Hashtag
	err := row.Scan(&i.ID, &i.Tag, &i.CreatedAt)
	return i, err
}

const getHashtagByTag = `-- name: GetHashtagByTag :one
SELECT id, tag, created_at FROM hashtags WHERE tag = ?
`

func (q *Queries) GetHashtagByTag(ctx context.Context, tag string) (Hashtag, error) {
	row := q.db.QueryRowContext(ctx, getHashtagByTag, tag)
	var i Hashtag
	err := row.Scan(&i.ID, &i.Tag, &i.CreatedAt)
	return i, err
}

const getHashtagCount = `-- name: GetHashtagCount :one
SELECT COUNT(*) FROM hashtags
`

func (q *Queries) GetHashtagCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getHashtagCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchHashtags = `-- name: SearchHashtags :many
SELECT id, tag, created_at FROM hashtags
WHERE tag LIKE CONCAT('%', ?, '%')
ORDER BY tag ASC
LIMIT ?
`

type SearchHashtagsParams struct {
	CONCAT interface{}
	Limit  int32
}

func (q *Queries) SearchHashtags(ctx context.Context, arg SearchHashtagsParams) ([]Hashtag, error) {
	rows, err := q.db.QueryContext(ctx, searchHashtags, arg.CONCAT, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hashtag
	for rows.Next() {
		var i Hashtag
		if err := rows.Scan(&i.ID, &i.Tag, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHashtagCreatedAt = `-- name: UpdateHashtagCreatedAt :exec
UPDATE hashtags
SET created_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) UpdateHashtagCreatedAt(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, updateHashtagCreatedAt, id)
	return err
}
