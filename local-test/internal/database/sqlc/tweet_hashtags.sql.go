// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tweet_hashtags.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const checkTweetHashtagExists = `-- name: CheckTweetHashtagExists :one
SELECT EXISTS(
    SELECT 1 FROM tweet_hashtags
    WHERE tweet_id = ? AND hashtag_id = ?
) AS hashtag_exists
`

type CheckTweetHashtagExistsParams struct {
	TweetID   uint64
	HashtagID uint64
}

func (q *Queries) CheckTweetHashtagExists(ctx context.Context, arg CheckTweetHashtagExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkTweetHashtagExists, arg.TweetID, arg.HashtagID)
	var hashtag_exists bool
	err := row.Scan(&hashtag_exists)
	return hashtag_exists, err
}

const createTweetHashtag = `-- name: CreateTweetHashtag :exec
INSERT INTO tweet_hashtags (tweet_id, hashtag_id)
VALUES (?, ?)
`

type CreateTweetHashtagParams struct {
	TweetID   uint64
	HashtagID uint64
}

func (q *Queries) CreateTweetHashtag(ctx context.Context, arg CreateTweetHashtagParams) error {
	_, err := q.db.ExecContext(ctx, createTweetHashtag, arg.TweetID, arg.HashtagID)
	return err
}

const deleteAllHashtagsForTweet = `-- name: DeleteAllHashtagsForTweet :exec
DELETE FROM tweet_hashtags
WHERE tweet_id = ?
`

func (q *Queries) DeleteAllHashtagsForTweet(ctx context.Context, tweetID uint64) error {
	_, err := q.db.ExecContext(ctx, deleteAllHashtagsForTweet, tweetID)
	return err
}

const deleteTweetHashtag = `-- name: DeleteTweetHashtag :exec
DELETE FROM tweet_hashtags
WHERE tweet_id = ? AND hashtag_id = ?
`

type DeleteTweetHashtagParams struct {
	TweetID   uint64
	HashtagID uint64
}

func (q *Queries) DeleteTweetHashtag(ctx context.Context, arg DeleteTweetHashtagParams) error {
	_, err := q.db.ExecContext(ctx, deleteTweetHashtag, arg.TweetID, arg.HashtagID)
	return err
}

const getHashtagsByTweetId = `-- name: GetHashtagsByTweetId :many
SELECT h.id, h.tag, h.created_at
FROM hashtags h
JOIN tweet_hashtags th ON h.id = th.hashtag_id
WHERE th.tweet_id = ?
`

func (q *Queries) GetHashtagsByTweetId(ctx context.Context, tweetID uint64) ([]Hashtag, error) {
	rows, err := q.db.QueryContext(ctx, getHashtagsByTweetId, tweetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Hashtag
	for rows.Next() {
		var i Hashtag
		if err := rows.Scan(&i.ID, &i.Tag, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostUsedHashtags = `-- name: GetMostUsedHashtags :many
SELECT h.id, h.tag, h.created_at, COUNT(th.tweet_id) as usage_count
FROM hashtags h
JOIN tweet_hashtags th ON h.id = th.hashtag_id
GROUP BY h.id
ORDER BY usage_count DESC
LIMIT ?
`

type GetMostUsedHashtagsRow struct {
	ID         uint64
	Tag        string
	CreatedAt  time.Time
	UsageCount int64
}

func (q *Queries) GetMostUsedHashtags(ctx context.Context, limit int32) ([]GetMostUsedHashtagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMostUsedHashtags, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostUsedHashtagsRow
	for rows.Next() {
		var i GetMostUsedHashtagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.CreatedAt,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentTweetsWithHashtag = `-- name: GetRecentTweetsWithHashtag :many
SELECT t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_retweet, t.is_reply, t.is_quote, t.engagement_score, t.media, t.created_at, t.updated_at, h.tag
FROM tweets t
JOIN tweet_hashtags th ON t.id = th.tweet_id
JOIN hashtags h ON th.hashtag_id = h.id
WHERE h.tag = ?
ORDER BY t.created_at DESC
LIMIT ?
`

type GetRecentTweetsWithHashtagParams struct {
	Tag   string
	Limit int32
}

type GetRecentTweetsWithHashtagRow struct {
	ID              uint64
	AccountID       string
	IsPinned        bool
	Content         sql.NullString
	Code            sql.NullString
	LikesCount      uint32
	RepliesCount    uint32
	RetweetsCount   uint32
	IsRetweet       bool
	IsReply         bool
	IsQuote         bool
	EngagementScore uint32
	Media           json.RawMessage
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Tag             string
}

func (q *Queries) GetRecentTweetsWithHashtag(ctx context.Context, arg GetRecentTweetsWithHashtagParams) ([]GetRecentTweetsWithHashtagRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentTweetsWithHashtag, arg.Tag, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentTweetsWithHashtagRow
	for rows.Next() {
		var i GetRecentTweetsWithHashtagRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTweetCountByHashtagId = `-- name: GetTweetCountByHashtagId :one
SELECT COUNT(DISTINCT tweet_id)
FROM tweet_hashtags
WHERE hashtag_id = ?
`

func (q *Queries) GetTweetCountByHashtagId(ctx context.Context, hashtagID uint64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTweetCountByHashtagId, hashtagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTweetsByHashtagId = `-- name: GetTweetsByHashtagId :many
SELECT t.id, t.account_id, t.is_pinned, t.content, t.code, t.likes_count, t.replies_count, t.retweets_count, t.is_retweet, t.is_reply, t.is_quote, t.engagement_score, t.media, t.created_at, t.updated_at
FROM tweets t
JOIN tweet_hashtags th ON t.id = th.tweet_id
WHERE th.hashtag_id = ?
ORDER BY t.created_at DESC
LIMIT ? OFFSET ?
`

type GetTweetsByHashtagIdParams struct {
	HashtagID uint64
	Limit     int32
	Offset    int32
}

func (q *Queries) GetTweetsByHashtagId(ctx context.Context, arg GetTweetsByHashtagIdParams) ([]Tweet, error) {
	rows, err := q.db.QueryContext(ctx, getTweetsByHashtagId, arg.HashtagID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tweet
	for rows.Next() {
		var i Tweet
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.IsPinned,
			&i.Content,
			&i.Code,
			&i.LikesCount,
			&i.RepliesCount,
			&i.RetweetsCount,
			&i.IsRetweet,
			&i.IsReply,
			&i.IsQuote,
			&i.EngagementScore,
			&i.Media,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
